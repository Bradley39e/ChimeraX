PREREQ_MAKE = 1
TOP	= ../..
include $(TOP)/mk/config.make

# PYTHON_VERSION is in config.make
PYTHON_PATCH_LEVEL = $(PYTHON_VERSION).1
DISTRIBUTION = Python-$(PYTHON_PATCH_LEVEL).tar.xz
SOURCE = $(tmpdir)/Python-$(PYTHON_PATCH_LEVEL)

PIP_VERSION = 8.1.2
WHEEL_VERSION = 0.29.0

ifdef WIN32
DYNLOAD_DIR = $(bindir)/DLLs
else
DYNLOAD_DIR = $(libdir)/python$(PYTHON_VERSION)/lib-dynload
endif

QUOTE_CC := $(subst ','\'',$(CC) $(TARGET_ARCH))
QUOTE_CXX := $(subst ','\'',$(CXX) $(TARGET_ARCH))

# Make Python use our compiler options
ENV_CONFIGURE = env CC='$(QUOTE_CC) -I$(includedir) -L$(libdir) -DUSE_DYLD_GLOBAL_NAMESPACE' CXX='$(QUOTE_CXX) -I$(includedir) -L$(libdir)'

ifdef DEBUG
ENV_CONFIGURE += OPT='$(OPT)'
endif

PATCHES	= $(wildcard Python-$(PYTHON_PATCH_LEVEL)-*.patch) \
	  $(wildcard Python-$(PYTHON_PATCH_LEVEL)_$(OS).patch) \
	  $(wildcard Python-$(PYTHON_PATCH_LEVEL)_$(OS)_$(OPENGL_PLATFORM).patch)
ifdef DEBUG
PATCHES += $(wildcard Python-$(PYTHON_PATCH_LEVEL)_debug.patch)
endif

ifeq ($(OS),Linux)
LDFLAGS += -Wl,-rpath,"$(libdir)"
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS)'
# On linux have to disable IPV6 socket support or _socket doesn't compile.
CONFIG_OPTIONS += --disable-ipv6 --enable-shared
endif
ifeq ($(OS),Darwin)
# On Darwin, -Wl,-rpath ends up in shared libraries in addition to executables,
# which we don't want, so we add the rpath later, and set the DYLD_LIBRARY_PATH
# to compensate while we're building
export DYLD_LIBRARY_PATH=$(libdir)
ifndef USE_MAC_FRAMEWORKS
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS)'
CONFIG_OPTIONS += --enable-shared
else
LDFLAGS += -Wl,-rpath,"$(libdir)"
CONFIG_OPTIONS += --enable-framework=$(frameworkdir) --prefix=$(build_prefix)
ifeq ($(PYTHON_VERSION).1,3.5.1)
# until 3.5.2 is available, to get Python to find the SQL libs on the Mac
# you have to *not* specify -isysroot (so it doesn't get confused by the new
# .tbd library stubs in the SDK) and you have to install the headers to /usr/include
# with "xcode-select --install"
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS) -F$(frameworkdir)'
else
# In order for Python's setup.py to decide that sqlite3 support is available,
# it needs to find the include file in the SDK, and it finds the SDK location
# by looking for a '-isysroot' flag in CFLAGS, so provide one...
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS) -F$(frameworkdir)' CFLAGS='$(CFLAGS) -isysroot $(SDK_PATH)'
endif
pyappdir = $(PYTHON_FRAMEWORK)/Resources/Python.app/Contents/MacOS
endif
endif

ifeq ($(OS),Windows)
ifeq ($(OSARCH),Windows64)
REGTOOL = regtool -w
CONFIG = Release
PLATFORM = x64
else
REGTOOL = regtool
CONFIG = Release
PLATFORM = Win32
endif
CONFIG_PLATFORM = '$(CONFIG)|$(PLATFORM)'

_PYDIR_MACHINE = /machine/SOFTWARE/Python/PythonCore/$(PYTHON_VERSION)/InstallPath/
_PYDIR_USER = /user/SOFTWARE/Python/PythonCore/$(PYTHON_VERSION)/InstallPath/
ifeq ($(shell $(REGTOOL) -q check $(_PYDIR_MACHINE) && echo found),found)
	PYDIR   = $(shell cygpath -u '$(shell $(REGTOOL) get $(_PYDIR_MACHINE))')
endif
ifeq ($(shell $(REGTOOL) -q check $(_PYDIR_USER) && echo found),found)
	PYDIR   = $(shell cygpath -u '$(shell $(REGTOOL) get $(_PYDIR_USER))')
endif
endif # Windows

ifdef DEBUG
CONFIG_OPTIONS += --with-pydebug
endif

ifneq (,$(shell [ ! -e $(TOP)/build_type ] || [ `cat $(TOP)/build_type` = alpha ] && echo found))
# stuff to do only if it is a private or daily build
ifneq (,$(wildcard /usr/include/valgrind/valgrind.h))
CONFIG_OPTIONS += --with-valgrind
endif
endif

# 64-bit Linux dies in exception handling if we don't link with the C++ compiler
CONFIG_OPTIONS += --with-cxx-main

all:

install: $(SOURCE)
ifeq ($(OS),Windows)
	#cd $(SOURCE)/PCbuild ; cmd /c build.bat -p $(PLATFORM) 
	#cd $(SOURCE)/PCbuild ; env HOST_PYTHON=`cygpath -m '$(SOURCE)/PCbuild/amd64/python3.exe'` devenv.com pcbuild.sln /build $(CONFIG_PLATFORM) /project _ssl
	test -n '$(PYDIR)'
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ --delete\
	  '$(PYDIR)'/DLLs \
	  '$(PYDIR)'/Lib \
	  '$(PYDIR)'/include \
	  '$(PYDIR)'/libs \
	  '$(PYDIR)'/python.exe \
	  '$(PYDIR)'/pythonw.exe \
	  '$(PYDIR)'/*.dll \
	  '$(bindir)'
	# Leave include and libs in bindir so pip/setuptools will work.
	# Also copy include and lib directories to common locations for
	# our source code.
	$(RSYNC) --delete '$(PYDIR)'/include/* \
		$(includedir)/python$(PYTHON_VERSION)$(PYTHON_ABI)
	$(RSYNC) '$(PYDIR)'/libs/* $(libdir)

else ifdef USE_MAC_FRAMEWORKS
	rm -rf $(frameworkdir)/Python.framework
	cd $(SOURCE) && $(MAKE) && $(MAKE) -j1 install
	rm -rf '$(build_prefix)/Applications/Python $(PYTHON_VERSION)'

	# copy bin, include, lib, and share to common location and leave symbolic links
	dir=$(PYTHON_FRAMEWORK)/bin; \
	if [ ! -L $$dir ]; \
	then \
		cd $$dir ; for i in *; do \
			rm -f $(bindir)/$$i; \
		done; \
		$(RSYNC) * $(bindir); \
		cd ..; rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(bindir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi
	dir=$(PYTHON_FRAMEWORK)/include; \
	if [ ! -L $$dir ]; \
	then \
		cp -r $$dir/* $(includedir); \
		rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(includedir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi
	dir=$(PYTHON_FRAMEWORK)/lib; \
	if [ ! -L $$dir ]; \
	then \
		cp -r $$dir/* $(libdir); \
		rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(libdir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi
	dir=$(PYTHON_FRAMEWORK)/share; \
	if [ ! -L $$dir ]; \
	then \
		cp -r $$dir/* $(datadir); \
		rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(datadir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi

	# remove unused libraries
	rm -rf $(PYTHON_LIBRARY_DIR)/config-*/*.{a,dylib}

	# replace python executable with version that doesn't invoke Python.app
	cp $(SOURCE)/python.exe $(PYTHON_EXE)
	install_name_tool -add_rpath '@executable_path/../lib' $(PYTHON_EXE)
	install_name_tool -change $(PYTHON_FRAMEWORK)/Python \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(PYTHON_FRAMEWORK)/Python", "$(bindir)"))') \
		$(PYTHON_EXE)

	$(PYTHON_EXE) fixsymlinks.py $(libdir) \
		$(libdir)/python$(PYTHON_VERSION)/config-$(PYTHON_VERSION)$(PYTHON_ABI)/*

	chmod 644 $(PYTHON_FRAMEWORK)/Python
	install_name_tool -id \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(PYTHON_FRAMEWORK)/Python", "$(bindir)"))') \
		$(PYTHON_FRAMEWORK)/Python
	chmod 444 $(PYTHON_FRAMEWORK)/Python

	# In Python 3.4 framework install only installs a python executable that uses Python.app in the framework.
	install_name_tool -add_rpath \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(libdir)", "$(pyappdir)"))') \
		$(pyappdir)/Python
	install_name_tool -change $(PYTHON_FRAMEWORK)/Python \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(PYTHON_FRAMEWORK)/Python", "$(pyappdir)"))') \
		$(pyappdir)/Python
	$(RSYNC) $(SOURCE)/Misc/valgrind-python.supp $(datadir)

else
	# Linux or Mac OS X without framework
	cd $(SOURCE) && $(MAKE) && $(MAKE) install
ifeq ($(OS),Linux)
	chrpath -r '$$ORIGIN/../lib' $(bindir)/python$(PYTHON_VERSION) $(bindir)/python$(PYTHON_VERSION)$(PYTHON_ABI)
endif
ifeq ($(OS),Darwin)
	install_name_tool -add_rpath '@executable_path/../lib' $(bindir)/python$(PYTHON_VERSION)
	pylib=libpython$(PYTHON_VERSION)$(PYTHON_ABI).dylib ;\
		chmod 644 $(libdir)/$$pylib ;\
		install_name_tool -id @rpath/$$pylib $(libdir)/$$pylib ;\
		chmod 444 $(libdir)/$$pylib
endif
	$(RSYNC) $(SOURCE)/Misc/valgrind-python.supp $(datadir)
endif
	# Since pip comes with Python 3.5, update it now so installs on
	# Windows will work.  Wheel is needed so bdist_wheel will work.
	$(PYTHON_EXE) -m ensurepip --upgrade
	# ignore errors upgrading pip to workaround remote Windows building bug
	-$(PYTHON_EXE) -m pip install --upgrade pip==$(PIP_VERSION)
	$(PYTHON_EXE) -m pip install --upgrade wheel==$(WHEEL_VERSION)

	# double check that _ssl was successfully made
	test -f $(DYNLOAD_DIR)/_ssl.*$(PYMOD_EXT)
	# double check that pyexpat was successfully made
	test -f $(DYNLOAD_DIR)/pyexpat.*$(PYMOD_EXT)

app-install:
	$(RSYNC) $(PYTHON_EXE) $(app_bindir)
ifeq ($(OS),Windows)
	# need include and libs so pip install will work
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ --delete\
	  '$(PYDIR)'/DLLs \
	  '$(PYDIR)'/Lib \
	  '$(PYDIR)'/include \
	  '$(PYDIR)'/libs \
	  '$(PYDIR)'/*.dll \
	  $(app_bindir)
else ifdef USE_MAC_FRAMEWORKS
	# next line breaks code signing 1/22/16
	#ln -nf $(app_bindir)/python$(PYTHON_VERSION) $(app_prefix)/MacOS/
	$(RSYNC) $(frameworkdir)/Python.framework $(app_frameworkdir)
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ \
		$(PYTHON_LIBRARY_DIR) $(app_libdir)
	$(RSYNC) $(datadir)/valgrind-python.supp $(app_datadir)
	$(RSYNC) $(includedir)/python$(PYTHON_VERSION)$(PYTHON_ABI) $(app_includedir)
else
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ \
		$(libdir)/libpython*.$(SHLIB_EXT)* \
		$(PYTHON_LIBRARY_DIR) $(app_libdir)
	$(RSYNC) $(includedir)/python$(PYTHON_VERSION)$(PYTHON_ABI) $(app_includedir)
	$(RSYNC) $(datadir)/valgrind-python.supp $(app_datadir)
endif
	$(APP_PYTHON_EXE) -m ensurepip --upgrade
	$(APP_PYTHON_EXE) -m pip install --upgrade \
		pip==$(PIP_VERSION) \
		wheel==$(WHEEL_VERSION)

$(SOURCE):
ifneq ($(OS),Windows)
	$(bindir)/7za e -so $(DISTRIBUTION) | tar xf - -C $(tmpdir)

	# avoid bootstrap (files generated by python, but python isn't built)
	cd $(SOURCE) && touch Python/Python-ast.c Include/Python-ast.h

ifneq (,$(PATCHES))
	for p in $(PATCHES); do \
		(cd $(SOURCE) && patch -f -p0) < $$p ; \
	done
endif
	cd $(SOURCE) && $(ENV_CONFIGURE) \
	    ./configure --prefix=$(build_prefix) $(CONFIG_OPTIONS)
	# Don't use stuff from /usr/local (especially Tcl, Tk, and SSL)
	cd $(SOURCE) && \
	    mv setup.py setup.py.orig ; \
	    sed -e 's;/usr/local;$(build_prefix);' -e 's;/ssl/;/;' < setup.py.orig > setup.py
ifdef USE_MAC_FRAMEWORKS
	# say where to find Tcl and Tk (and any other frameworks)
	(echo ':/framework_dirs =/s:$$: "$(frameworkdir)",:'; echo ':wq') \
	    | env TERM=dumb ex -s $(SOURCE)/setup.py
	(echo ':/^BASECFLAGS/s:$$: -F$(frameworkdir):'; echo ':wq') \
	    | env TERM=dumb ex -s $(SOURCE)/Makefile
endif
endif

clean:
	rm -rf $(SOURCE)
