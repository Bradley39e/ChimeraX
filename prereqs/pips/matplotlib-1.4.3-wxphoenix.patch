*** matplotlib/backends/backend_wx.py.orig	Sun Feb 15 19:46:36 2015
--- matplotlib/backends/backend_wx.py	Tue Mar 17 11:42:23 2015
***************
*** 29,34 ****
--- 29,55 ----
  import numpy as np
  
  from matplotlib.cbook import mplDeprecation
+ import matplotlib
+ from matplotlib import verbose
+ from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\
+     FigureCanvasBase, FigureManagerBase, NavigationToolbar2, \
+     cursors, TimerBase
+ from matplotlib.backend_bases import ShowBase
+ from matplotlib.backend_bases import _has_pil
+ 
+ from matplotlib._pylab_helpers import Gcf
+ from matplotlib.artist import Artist
+ from matplotlib.cbook import exception_to_str, is_string_like, \
+     is_writable_file_like
+ from matplotlib.figure import Figure
+ from matplotlib.path import Path
+ from matplotlib.text import _process_text_args, Text
+ from matplotlib.transforms import Affine2D
+ from matplotlib.widgets import SubplotTool
+ from matplotlib import rcParams
+ 
+ from . import wx_compat as wxc
+ import wx
  
  # Debugging settings here...
  # Debug level set here. If the debug level is less than 5, information
***************
*** 37,91 ****
  # this case
  _DEBUG = 5
  if _DEBUG < 5:
!     import traceback, pdb
! _DEBUG_lvls = {1 : 'Low ', 2 : 'Med ', 3 : 'High', 4 : 'Error' }
! 
! if six.PY3:
!     warnings.warn(
!         "The wx and wxagg backends have not been tested with Python 3.x",
!         ImportWarning)
! 
! missingwx = "Matplotlib backend_wx and backend_wxagg require wxPython >=2.8"
! missingwxversion = ("Matplotlib backend_wx and backend_wxagg "
!                     "require wxversion, which was not found.")
! 
! if not hasattr(sys, 'frozen'): # i.e., not py2exe
!     try:
!         import wxversion
!     except ImportError:
!         raise ImportError(missingwxversion)
! 
!     # Some early versions of wxversion lack AlreadyImportedError.
!     # It was added around 2.8.4?
!     try:
!         _wx_ensure_failed = wxversion.AlreadyImportedError
!     except AttributeError:
!         _wx_ensure_failed = wxversion.VersionError
! 
!     try:
!         wxversion.ensureMinimal(str('2.8'))
!     except _wx_ensure_failed:
!         pass
!     # We don't really want to pass in case of VersionError, but when
!     # AlreadyImportedError is not available, we have to.
  
- try:
-     import wx
-     backend_version = wx.VERSION_STRING
- except ImportError:
-     raise ImportError(missingwx)
- 
- # Extra version check in case wxversion lacks AlreadyImportedError;
- # then VersionError might have been raised and ignored when
- # there really *is* a problem with the version.
- major, minor = [int(n) for n in backend_version.split('.')[:2]]
- if major < 2 or (major < 3 and minor < 8):
-     print(" wxPython version %s was imported." % backend_version)
-     raise ImportError(missingwx)
- 
- 
- #!!! this is the call that is causing the exception swallowing !!!
- #wx.InitAllImageHandlers()
  
  def DEBUG_MSG(string, lvl=3, o=None):
      if lvl >= _DEBUG:
--- 58,67 ----
  # this case
  _DEBUG = 5
  if _DEBUG < 5:
!     import traceback
!     import pdb
! _DEBUG_lvls = {1: 'Low ', 2: 'Med ', 3: 'High', 4: 'Error'}
  
  
  def DEBUG_MSG(string, lvl=3, o=None):
      if lvl >= _DEBUG:
***************
*** 96,167 ****
          #print >>sys.stderr, "%s- %s in %s" % (_DEBUG_lvls[lvl], string, cls)
          print("%s- %s in %s" % (_DEBUG_lvls[lvl], string, cls))
  
  def debug_on_error(type, value, tb):
      """Code due to Thomas Heller - published in Python Cookbook (O'Reilley)"""
      traceback.print_exc(type, value, tb)
      print()
      pdb.pm()  # jdh uncomment
  
! class fake_stderr:
!     """Wx does strange things with stderr, as it makes the assumption that there
!     is probably no console. This redirects stderr to the console, since we know
!     that there is one!"""
      def write(self, msg):
          print("Stderr: %s\n\r" % msg)
  
  #if _DEBUG < 5:
! #    sys.excepthook = debug_on_error
! #    WxLogger =wx.LogStderr()
! #    sys.stderr = fake_stderr
! 
! # Event binding code changed after version 2.5
! if wx.VERSION_STRING >= '2.5':
!     def bind(actor,event,action,**kw):
!         actor.Bind(event,action,**kw)
! else:
!     def bind(actor,event,action,id=None):
!         if id is not None:
!             event(actor, id, action)
!         else:
!             event(actor,action)
! 
! import matplotlib
! from matplotlib import verbose
! from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\
!      FigureCanvasBase, FigureManagerBase, NavigationToolbar2, \
!      cursors, TimerBase
! from matplotlib.backend_bases import ShowBase
! from matplotlib.backend_bases import _has_pil
! 
! from matplotlib._pylab_helpers import Gcf
! from matplotlib.artist import Artist
! from matplotlib.cbook import exception_to_str, is_string_like, is_writable_file_like
! from matplotlib.figure import Figure
! from matplotlib.path import Path
! from matplotlib.text import _process_text_args, Text
! from matplotlib.transforms import Affine2D
! from matplotlib.widgets import SubplotTool
! from matplotlib import rcParams
  
  # the True dots per inch on the screen; should be display dependent
! # see http://groups.google.com/groups?q=screen+dpi+x11&hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=7077.26e81ad5%40swift.cs.tcd.ie&rnum=5 for some info about screen dpi
  PIXELS_PER_INCH = 75
  
  # Delay time for idle checks
  IDLE_DELAY = 5
  
  def error_msg_wx(msg, parent=None):
      """
      Signal an error condition -- in a GUI, popup a error dialog
      """
!     dialog =wx.MessageDialog(parent  = parent,
!                              message = msg,
!                              caption = 'Matplotlib backend_wx error',
!                              style=wx.OK | wx.CENTRE)
      dialog.ShowModal()
      dialog.Destroy()
      return None
  
  def raise_msg_to_str(msg):
      """msg is a return arg from a raise.  Join with new lines"""
      if not is_string_like(msg):
--- 72,123 ----
          #print >>sys.stderr, "%s- %s in %s" % (_DEBUG_lvls[lvl], string, cls)
          print("%s- %s in %s" % (_DEBUG_lvls[lvl], string, cls))
  
+ 
  def debug_on_error(type, value, tb):
      """Code due to Thomas Heller - published in Python Cookbook (O'Reilley)"""
      traceback.print_exc(type, value, tb)
      print()
      pdb.pm()  # jdh uncomment
  
! 
! class fake_stderr(object):
!     """
!     Wx does strange things with stderr, as it makes the assumption that
!     there is probably no console. This redirects stderr to the console, since
!     we know that there is one!
!     """
! 
      def write(self, msg):
          print("Stderr: %s\n\r" % msg)
  
  #if _DEBUG < 5:
!     #sys.excepthook = debug_on_error
!     #WxLogger =wx.LogStderr()
!     #sys.stderr = fake_stderr
  
  # the True dots per inch on the screen; should be display dependent
! # see
! # http://groups.google.com/groups?q=screen+dpi+x11&hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=7077.26e81ad5%40swift.cs.tcd.ie&rnum=5
! # for some info about screen dpi
  PIXELS_PER_INCH = 75
  
  # Delay time for idle checks
  IDLE_DELAY = 5
  
+ 
  def error_msg_wx(msg, parent=None):
      """
      Signal an error condition -- in a GUI, popup a error dialog
      """
!     dialog = wx.MessageDialog(parent=parent,
!                               message=msg,
!                               caption='Matplotlib backend_wx error',
!                               style=wx.OK | wx.CENTRE)
      dialog.ShowModal()
      dialog.Destroy()
      return None
  
+ 
  def raise_msg_to_str(msg):
      """msg is a return arg from a raise.  Join with new lines"""
      if not is_string_like(msg):
***************
*** 182,187 ****
--- 138,144 ----
          upon timer events. This list can be manipulated directly, or the
          functions add_callback and remove_callback can be used.
      '''
+ 
      def __init__(self, parent, *args, **kwargs):
          TimerBase.__init__(self, *args, **kwargs)
  
***************
*** 218,267 ****
      context instance that controls the colors/styles. It acts as the
      'renderer' instance used by many classes in the hierarchy.
      """
!     #In wxPython, drawing is performed on a wxDC instance, which will
!     #generally be mapped to the client aread of the window displaying
!     #the plot. Under wxPython, the wxDC instance has a wx.Pen which
!     #describes the colour and weight of any lines drawn, and a wxBrush
!     #which describes the fill colour of any closed polygon.
! 
! 
!     fontweights = {
!         100          : wx.LIGHT,
!         200          : wx.LIGHT,
!         300          : wx.LIGHT,
!         400          : wx.NORMAL,
!         500          : wx.NORMAL,
!         600          : wx.NORMAL,
!         700          : wx.BOLD,
!         800          : wx.BOLD,
!         900          : wx.BOLD,
!         'ultralight' : wx.LIGHT,
!         'light'      : wx.LIGHT,
!         'normal'     : wx.NORMAL,
!         'medium'     : wx.NORMAL,
!         'semibold'   : wx.NORMAL,
!         'bold'       : wx.BOLD,
!         'heavy'      : wx.BOLD,
!         'ultrabold'  : wx.BOLD,
!         'black'      : wx.BOLD
!         }
!     fontangles = {
!         'italic'  : wx.ITALIC,
!         'normal'  : wx.NORMAL,
!         'oblique' : wx.SLANT }
  
      # wxPython allows for portable font styles, choosing them appropriately
      # for the target platform. Map some standard font names to the portable
      # styles
      # QUESTION: Is it be wise to agree standard fontnames across all backends?
!     fontnames = { 'Sans'       : wx.SWISS,
!                   'Roman'      : wx.ROMAN,
!                   'Script'     : wx.SCRIPT,
!                   'Decorative' : wx.DECORATIVE,
!                   'Modern'     : wx.MODERN,
!                   'Courier'    : wx.MODERN,
!                   'courier'    : wx.MODERN }
! 
  
      def __init__(self, bitmap, dpi):
          """
--- 175,194 ----
      context instance that controls the colors/styles. It acts as the
      'renderer' instance used by many classes in the hierarchy.
      """
!     # In wxPython, drawing is performed on a wxDC instance, which will
!     # generally be mapped to the client aread of the window displaying
!     # the plot. Under wxPython, the wxDC instance has a wx.Pen which
!     # describes the colour and weight of any lines drawn, and a wxBrush
!     # which describes the fill colour of any closed polygon.
! 
!     fontweights = wxc.fontweights
!     fontangles = wxc.fontangles
  
      # wxPython allows for portable font styles, choosing them appropriately
      # for the target platform. Map some standard font names to the portable
      # styles
      # QUESTION: Is it be wise to agree standard fontnames across all backends?
!     fontnames = wxc.fontnames
  
      def __init__(self, bitmap, dpi):
          """
***************
*** 270,277 ****
          RendererBase.__init__(self)
          DEBUG_MSG("__init__()", 1, self)
          if wx.VERSION_STRING < "2.8":
!             raise RuntimeError("matplotlib no longer supports wxPython < 2.8 for the Wx backend.\nYou may, however, use the WxAgg backend.")
!         self.width  = bitmap.GetWidth()
          self.height = bitmap.GetHeight()
          self.bitmap = bitmap
          self.fontd = {}
--- 197,206 ----
          RendererBase.__init__(self)
          DEBUG_MSG("__init__()", 1, self)
          if wx.VERSION_STRING < "2.8":
!             raise RuntimeError(
!                 "matplotlib no longer supports wxPython < 2.8 for"
!                 "the Wx backends.")
!         self.width = bitmap.GetWidth()
          self.height = bitmap.GetHeight()
          self.bitmap = bitmap
          self.fontd = {}
***************
*** 289,296 ****
          get the width and height in display coords of the string s
          with FontPropertry prop
          """
!         #return 1, 1
!         if ismath: s = self.strip_math(s)
  
          if self.gc is None:
              gc = self.new_gc()
--- 218,226 ----
          get the width and height in display coords of the string s
          with FontPropertry prop
          """
!         # return 1, 1
!         if ismath:
!             s = self.strip_math(s)
  
          if self.gc is None:
              gc = self.new_gc()
***************
*** 317,323 ****
              if new_bounds is None:
                  gfx_ctx.ResetClip()
              else:
!                 gfx_ctx.Clip(new_bounds[0], self.height - new_bounds[1] - new_bounds[3],
                               new_bounds[2], new_bounds[3])
  
      @staticmethod
--- 247,254 ----
              if new_bounds is None:
                  gfx_ctx.ResetClip()
              else:
!                 gfx_ctx.Clip(new_bounds[0],
!                              self.height - new_bounds[1] - new_bounds[3],
                               new_bounds[2], new_bounds[3])
  
      @staticmethod
***************
*** 340,346 ****
          gc.select()
          self.handle_clip_rectangle(gc)
          gfx_ctx = gc.gfx_ctx
!         transform = transform + Affine2D().scale(1.0, -1.0).translate(0.0, self.height)
          wxpath = self.convert_path(gfx_ctx, path, transform)
          if rgbFace is not None:
              gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))
--- 271,278 ----
          gc.select()
          self.handle_clip_rectangle(gc)
          gfx_ctx = gc.gfx_ctx
!         transform = transform + \
!             Affine2D().scale(1.0, -1.0).translate(0.0, self.height)
          wxpath = self.convert_path(gfx_ctx, path, transform)
          if rgbFace is not None:
              gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))
***************
*** 351,374 ****
  
      def draw_image(self, gc, x, y, im):
          bbox = gc.get_clip_rectangle()
!         if bbox != None:
!             l,b,w,h = bbox.bounds
          else:
!             l=0
!             b=0,
!             w=self.width
!             h=self.height
          rows, cols, image_str = im.as_rgba_str()
          image_array = np.fromstring(image_str, np.uint8)
          image_array.shape = rows, cols, 4
!         bitmap = wx.BitmapFromBufferRGBA(cols,rows,image_array)
          gc = self.get_gc()
          gc.select()
!         gc.gfx_ctx.DrawBitmap(bitmap,int(l),int(self.height-b),int(w),int(-h))
          gc.unselect()
  
      def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):
!         if ismath: s = self.strip_math(s)
          DEBUG_MSG("draw_text()", 1, self)
          gc.select()
          self.handle_clip_rectangle(gc)
--- 283,308 ----
  
      def draw_image(self, gc, x, y, im):
          bbox = gc.get_clip_rectangle()
!         if bbox is not None:
!             l, b, w, h = bbox.bounds
          else:
!             l = 0
!             b = 0
!             w = self.width
!             h = self.height
          rows, cols, image_str = im.as_rgba_str()
          image_array = np.fromstring(image_str, np.uint8)
          image_array.shape = rows, cols, 4
!         bitmap = wxc.BitmapFromBuffer(cols, rows, image_array)
          gc = self.get_gc()
          gc.select()
!         gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),
!                               int(w), int(-h))
          gc.unselect()
  
      def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):
!         if ismath:
!             s = self.strip_math(s)
          DEBUG_MSG("draw_text()", 1, self)
          gc.select()
          self.handle_clip_rectangle(gc)
***************
*** 380,386 ****
  
          w, h, d = self.get_text_width_height_descent(s, prop, ismath)
          x = int(x)
!         y = int(y-h)
  
          if angle == 0.0:
              gfx_ctx.DrawText(s, x, y)
--- 314,320 ----
  
          w, h, d = self.get_text_width_height_descent(s, prop, ismath)
          x = int(x)
!         y = int(y - h)
  
          if angle == 0.0:
              gfx_ctx.DrawText(s, x, y)
***************
*** 408,414 ****
          """
          # This is a dirty hack to allow anything with access to a renderer to
          # access the current graphics context
!         assert self.gc != None, "gc must be defined"
          return self.gc
  
      def get_wx_font(self, s, prop):
--- 342,348 ----
          """
          # This is a dirty hack to allow anything with access to a renderer to
          # access the current graphics context
!         assert self.gc is not None, "gc must be defined"
          return self.gc
  
      def get_wx_font(self, s, prop):
***************
*** 418,424 ****
          """
          DEBUG_MSG("get_wx_font()", 1, self)
  
- 
          key = hash(prop)
          fontprop = prop
          fontname = fontprop.get_name()
--- 352,357 ----
***************
*** 429,447 ****
  
          # Allow use of platform independent and dependent font names
          wxFontname = self.fontnames.get(fontname, wx.ROMAN)
!         wxFacename = '' # Empty => wxPython chooses based on wx_fontname
  
          # Font colour is determined by the active wx.Pen
          # TODO: It may be wise to cache font information
          size = self.points_to_pixels(fontprop.get_size_in_points())
  
! 
!         font =wx.Font(int(size+0.5),             # Size
!                       wxFontname,                # 'Generic' name
!                       self.fontangles[fontprop.get_style()],   # Angle
!                       self.fontweights[fontprop.get_weight()], # Weight
!                       False,                     # Underline
!                       wxFacename)                # Platform font name
  
          # cache the font and gc and return it
          self.fontd[key] = font
--- 362,379 ----
  
          # Allow use of platform independent and dependent font names
          wxFontname = self.fontnames.get(fontname, wx.ROMAN)
!         wxFacename = ''  # Empty => wxPython chooses based on wx_fontname
  
          # Font colour is determined by the active wx.Pen
          # TODO: It may be wise to cache font information
          size = self.points_to_pixels(fontprop.get_size_in_points())
  
!         font = wx.Font(int(size + 0.5),             # Size
!                        wxFontname,                # 'Generic' name
!                        self.fontangles[fontprop.get_style()],   # Angle
!                        self.fontweights[fontprop.get_weight()],  # Weight
!                        False,                     # Underline
!                        wxFacename)                # Platform font name
  
          # cache the font and gc and return it
          self.fontd[key] = font
***************
*** 453,459 ****
          convert point measures to pixes using dpi and the pixels per
          inch of the display
          """
!         return points*(PIXELS_PER_INCH/72.0*self.dpi/72.0)
  
  
  class GraphicsContextWx(GraphicsContextBase):
--- 385,391 ----
          convert point measures to pixes using dpi and the pixels per
          inch of the display
          """
!         return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)
  
  
  class GraphicsContextWx(GraphicsContextBase):
***************
*** 470,493 ****
      since wxPython colour management is rather simple, I have not chosen
      to implement a separate colour manager class.
      """
!     _capd = { 'butt':       wx.CAP_BUTT,
!               'projecting': wx.CAP_PROJECTING,
!               'round':      wx.CAP_ROUND }
! 
!     _joind = { 'bevel':     wx.JOIN_BEVEL,
!                'miter':     wx.JOIN_MITER,
!                'round':     wx.JOIN_ROUND }
! 
!     _dashd_wx = { 'solid':     wx.SOLID,
!                   'dashed':    wx.SHORT_DASH,
!                   'dashdot':   wx.DOT_DASH,
!                   'dotted':    wx.DOT }
      _cache = weakref.WeakKeyDictionary()
  
      def __init__(self, bitmap, renderer):
          GraphicsContextBase.__init__(self)
          #assert self.Ok(), "wxMemoryDC not OK to use"
          DEBUG_MSG("__init__()", 1, self)
  
          dc, gfx_ctx = self._cache.get(bitmap, (None, None))
          if dc is None:
--- 402,424 ----
      since wxPython colour management is rather simple, I have not chosen
      to implement a separate colour manager class.
      """
!     _capd = {'butt': wx.CAP_BUTT,
!              'projecting': wx.CAP_PROJECTING,
!              'round': wx.CAP_ROUND}
! 
!     _joind = {'bevel': wx.JOIN_BEVEL,
!               'miter': wx.JOIN_MITER,
!               'round': wx.JOIN_ROUND}
! 
!     _dashd_wx = wxc.dashd_wx
! 
      _cache = weakref.WeakKeyDictionary()
  
      def __init__(self, bitmap, renderer):
          GraphicsContextBase.__init__(self)
          #assert self.Ok(), "wxMemoryDC not OK to use"
          DEBUG_MSG("__init__()", 1, self)
+         DEBUG_MSG("__init__() 2: %s" % bitmap, 1, self)
  
          dc, gfx_ctx = self._cache.get(bitmap, (None, None))
          if dc is None:
***************
*** 510,516 ****
          Select the current bitmap into this wxDC instance
          """
  
!         if sys.platform=='win32':
              self.dc.SelectObject(self.bitmap)
              self.IsSelected = True
  
--- 441,447 ----
          Select the current bitmap into this wxDC instance
          """
  
!         if sys.platform == 'win32':
              self.dc.SelectObject(self.bitmap)
              self.IsSelected = True
  
***************
*** 518,524 ****
          """
          Select a Null bitmasp into this wxDC instance
          """
!         if sys.platform=='win32':
              self.dc.SelectObject(wx.NullBitmap)
              self.IsSelected = False
  
--- 449,455 ----
          """
          Select a Null bitmasp into this wxDC instance
          """
!         if sys.platform == 'win32':
              self.dc.SelectObject(wx.NullBitmap)
              self.IsSelected = False
  
***************
*** 560,569 ****
          """
          DEBUG_MSG("set_linewidth()", 1, self)
          self.select()
!         if w>0 and w<1: w = 1
          GraphicsContextBase.set_linewidth(self, w)
          lw = int(self.renderer.points_to_pixels(self._linewidth))
!         if lw==0: lw = 1
          self._pen.SetWidth(lw)
          self.gfx_ctx.SetPen(self._pen)
          self.unselect()
--- 491,502 ----
          """
          DEBUG_MSG("set_linewidth()", 1, self)
          self.select()
!         if w > 0 and w < 1:
!             w = 1
          GraphicsContextBase.set_linewidth(self, w)
          lw = int(self.renderer.points_to_pixels(self._linewidth))
!         if lw == 0:
!             lw = 1
          self._pen.SetWidth(lw)
          self.gfx_ctx.SetPen(self._pen)
          self.unselect()
***************
*** 600,606 ****
          try:
              self._style = GraphicsContextWx._dashd_wx[ls]
          except KeyError:
!             self._style = wx.LONG_DASH# Style not used elsewhere...
  
          # On MS Windows platform, only line width of 1 allowed for dash lines
          if wx.Platform == '__WXMSW__':
--- 533,539 ----
          try:
              self._style = GraphicsContextWx._dashd_wx[ls]
          except KeyError:
!             self._style = wx.LONG_DASH  # Style not used elsewhere...
  
          # On MS Windows platform, only line width of 1 allowed for dash lines
          if wx.Platform == '__WXMSW__':
***************
*** 625,631 ****
              g *= 255
              b *= 255
              a *= 255
!             return wx.Colour(red=int(r), green=int(g), blue=int(b), alpha=int(a))
  
  
  class FigureCanvasWx(FigureCanvasBase, wx.Panel):
--- 558,568 ----
              g *= 255
              b *= 255
              a *= 255
!             return wx.Colour(
!                 red=int(r),
!                 green=int(g),
!                 blue=int(b),
!                 alpha=int(a))
  
  
  class FigureCanvasWx(FigureCanvasBase, wx.Panel):
***************
*** 633,705 ****
      The FigureCanvas contains the figure and does event handling.
  
      In the wxPython backend, it is derived from wxPanel, and (usually) lives
!     inside a frame instantiated by a FigureManagerWx. The parent window probably
!     implements a wx.Sizer to control the displayed control size - but we give a
!     hint as to our preferred minimum size.
      """
  
      keyvald = {
!         wx.WXK_CONTROL         : 'control',
!         wx.WXK_SHIFT           : 'shift',
!         wx.WXK_ALT             : 'alt',
!         wx.WXK_LEFT            : 'left',
!         wx.WXK_UP              : 'up',
!         wx.WXK_RIGHT           : 'right',
!         wx.WXK_DOWN            : 'down',
!         wx.WXK_ESCAPE          : 'escape',
!         wx.WXK_F1              : 'f1',
!         wx.WXK_F2              : 'f2',
!         wx.WXK_F3              : 'f3',
!         wx.WXK_F4              : 'f4',
!         wx.WXK_F5              : 'f5',
!         wx.WXK_F6              : 'f6',
!         wx.WXK_F7              : 'f7',
!         wx.WXK_F8              : 'f8',
!         wx.WXK_F9              : 'f9',
!         wx.WXK_F10             : 'f10',
!         wx.WXK_F11             : 'f11',
!         wx.WXK_F12             : 'f12',
!         wx.WXK_SCROLL          : 'scroll_lock',
!         wx.WXK_PAUSE           : 'break',
!         wx.WXK_BACK            : 'backspace',
!         wx.WXK_RETURN          : 'enter',
!         wx.WXK_INSERT          : 'insert',
!         wx.WXK_DELETE          : 'delete',
!         wx.WXK_HOME            : 'home',
!         wx.WXK_END             : 'end',
!         wx.WXK_PRIOR           : 'pageup',
!         wx.WXK_NEXT            : 'pagedown',
!         wx.WXK_PAGEUP          : 'pageup',
!         wx.WXK_PAGEDOWN        : 'pagedown',
!         wx.WXK_NUMPAD0         : '0',
!         wx.WXK_NUMPAD1         : '1',
!         wx.WXK_NUMPAD2         : '2',
!         wx.WXK_NUMPAD3         : '3',
!         wx.WXK_NUMPAD4         : '4',
!         wx.WXK_NUMPAD5         : '5',
!         wx.WXK_NUMPAD6         : '6',
!         wx.WXK_NUMPAD7         : '7',
!         wx.WXK_NUMPAD8         : '8',
!         wx.WXK_NUMPAD9         : '9',
!         wx.WXK_NUMPAD_ADD      : '+',
!         wx.WXK_NUMPAD_SUBTRACT : '-',
!         wx.WXK_NUMPAD_MULTIPLY : '*',
!         wx.WXK_NUMPAD_DIVIDE   : '/',
!         wx.WXK_NUMPAD_DECIMAL  : 'dec',
!         wx.WXK_NUMPAD_ENTER    : 'enter',
!         wx.WXK_NUMPAD_UP       : 'up',
!         wx.WXK_NUMPAD_RIGHT    : 'right',
!         wx.WXK_NUMPAD_DOWN     : 'down',
!         wx.WXK_NUMPAD_LEFT     : 'left',
!         wx.WXK_NUMPAD_PRIOR    : 'pageup',
!         wx.WXK_NUMPAD_NEXT     : 'pagedown',
!         wx.WXK_NUMPAD_PAGEUP   : 'pageup',
!         wx.WXK_NUMPAD_PAGEDOWN : 'pagedown',
!         wx.WXK_NUMPAD_HOME     : 'home',
!         wx.WXK_NUMPAD_END      : 'end',
!         wx.WXK_NUMPAD_INSERT   : 'insert',
!         wx.WXK_NUMPAD_DELETE   : 'delete',
!         }
  
      def __init__(self, parent, id, figure):
          """
--- 570,638 ----
      The FigureCanvas contains the figure and does event handling.
  
      In the wxPython backend, it is derived from wxPanel, and (usually) lives
!     inside a frame instantiated by a FigureManagerWx. The parent window
!     probably implements a wx.Sizer to control the displayed control size - but
!     we give a hint as to our preferred minimum size.
      """
  
      keyvald = {
!         wx.WXK_CONTROL: 'control',
!         wx.WXK_SHIFT: 'shift',
!         wx.WXK_ALT: 'alt',
!         wx.WXK_LEFT: 'left',
!         wx.WXK_UP: 'up',
!         wx.WXK_RIGHT: 'right',
!         wx.WXK_DOWN: 'down',
!         wx.WXK_ESCAPE: 'escape',
!         wx.WXK_F1: 'f1',
!         wx.WXK_F2: 'f2',
!         wx.WXK_F3: 'f3',
!         wx.WXK_F4: 'f4',
!         wx.WXK_F5: 'f5',
!         wx.WXK_F6: 'f6',
!         wx.WXK_F7: 'f7',
!         wx.WXK_F8: 'f8',
!         wx.WXK_F9: 'f9',
!         wx.WXK_F10: 'f10',
!         wx.WXK_F11: 'f11',
!         wx.WXK_F12: 'f12',
!         wx.WXK_SCROLL: 'scroll_lock',
!         wx.WXK_PAUSE: 'break',
!         wx.WXK_BACK: 'backspace',
!         wx.WXK_RETURN: 'enter',
!         wx.WXK_INSERT: 'insert',
!         wx.WXK_DELETE: 'delete',
!         wx.WXK_HOME: 'home',
!         wx.WXK_END: 'end',
!         wx.WXK_PAGEUP: 'pageup',
!         wx.WXK_PAGEDOWN: 'pagedown',
!         wx.WXK_NUMPAD0: '0',
!         wx.WXK_NUMPAD1: '1',
!         wx.WXK_NUMPAD2: '2',
!         wx.WXK_NUMPAD3: '3',
!         wx.WXK_NUMPAD4: '4',
!         wx.WXK_NUMPAD5: '5',
!         wx.WXK_NUMPAD6: '6',
!         wx.WXK_NUMPAD7: '7',
!         wx.WXK_NUMPAD8: '8',
!         wx.WXK_NUMPAD9: '9',
!         wx.WXK_NUMPAD_ADD: '+',
!         wx.WXK_NUMPAD_SUBTRACT: '-',
!         wx.WXK_NUMPAD_MULTIPLY: '*',
!         wx.WXK_NUMPAD_DIVIDE: '/',
!         wx.WXK_NUMPAD_DECIMAL: 'dec',
!         wx.WXK_NUMPAD_ENTER: 'enter',
!         wx.WXK_NUMPAD_UP: 'up',
!         wx.WXK_NUMPAD_RIGHT: 'right',
!         wx.WXK_NUMPAD_DOWN: 'down',
!         wx.WXK_NUMPAD_LEFT: 'left',
!         wx.WXK_NUMPAD_PAGEUP: 'pageup',
!         wx.WXK_NUMPAD_PAGEDOWN: 'pagedown',
!         wx.WXK_NUMPAD_HOME: 'home',
!         wx.WXK_NUMPAD_END: 'end',
!         wx.WXK_NUMPAD_INSERT: 'insert',
!         wx.WXK_NUMPAD_DELETE: 'delete',
!     }
  
      def __init__(self, parent, id, figure):
          """
***************
*** 714,792 ****
          FigureCanvasBase.__init__(self, figure)
          # Set preferred window size hint - helps the sizer (if one is
          # connected)
!         l,b,w,h = figure.bbox.bounds
          w = int(math.ceil(w))
          h = int(math.ceil(h))
  
          wx.Panel.__init__(self, parent, id, size=wx.Size(w, h))
  
          def do_nothing(*args, **kwargs):
!             warnings.warn('could not find a setinitialsize function for backend_wx; please report your wxpython version=%s to the matplotlib developers list'%backend_version)
              pass
  
          # try to find the set size func across wx versions
          try:
              getattr(self, 'SetInitialSize')
          except AttributeError:
!             self.SetInitialSize = getattr(self, 'SetBestFittingSize', do_nothing)
! 
! 
!         if not hasattr(self,'IsShownOnScreen'):
!             self.IsShownOnScreen = getattr(self, 'IsVisible', lambda *args: True)
! 
  
          # Create the drawing bitmap
!         self.bitmap =wx.EmptyBitmap(w, h)
!         DEBUG_MSG("__init__() - bitmap w:%d h:%d" % (w,h), 2, self)
          # TODO: Add support for 'point' inspection and plot navigation.
          self._isDrawn = False
  
!         bind(self, wx.EVT_SIZE, self._onSize)
!         bind(self, wx.EVT_PAINT, self._onPaint)
!         bind(self, wx.EVT_ERASE_BACKGROUND, self._onEraseBackground)
!         bind(self, wx.EVT_KEY_DOWN, self._onKeyDown)
!         bind(self, wx.EVT_KEY_UP, self._onKeyUp)
!         bind(self, wx.EVT_RIGHT_DOWN, self._onRightButtonDown)
!         bind(self, wx.EVT_RIGHT_DCLICK, self._onRightButtonDClick)
!         bind(self, wx.EVT_RIGHT_UP, self._onRightButtonUp)
!         bind(self, wx.EVT_MOUSEWHEEL, self._onMouseWheel)
!         bind(self, wx.EVT_LEFT_DOWN, self._onLeftButtonDown)
!         bind(self, wx.EVT_LEFT_DCLICK, self._onLeftButtonDClick)
!         bind(self, wx.EVT_LEFT_UP, self._onLeftButtonUp)
!         bind(self, wx.EVT_MOTION, self._onMotion)
!         bind(self, wx.EVT_LEAVE_WINDOW, self._onLeave)
!         bind(self, wx.EVT_ENTER_WINDOW, self._onEnter)
!         bind(self, wx.EVT_IDLE, self._onIdle)
!         #Add middle button events
!         bind(self, wx.EVT_MIDDLE_DOWN, self._onMiddleButtonDown)
!         bind(self, wx.EVT_MIDDLE_DCLICK, self._onMiddleButtonDClick)
!         bind(self, wx.EVT_MIDDLE_UP, self._onMiddleButtonUp)
! 
!         self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
! 
!         self.macros = {} # dict from wx id to seq of macros
! 
!         # printer attributes and methods deprecated, 2010/06/19
!         self._printerData = None
!         self._printerPageData = None
!         self.printer_width = 5.5
!         self.printer_margin = 0.5
  
      def Destroy(self, *args, **kwargs):
          wx.Panel.Destroy(self, *args, **kwargs)
  
- 
      def Copy_to_Clipboard(self, event=None):
          "copy bitmap of canvas to system clipboard"
          bmp_obj = wx.BitmapDataObject()
          bmp_obj.SetBitmap(self.bitmap)
  
          if not wx.TheClipboard.IsOpened():
!            open_success = wx.TheClipboard.Open()
!            if open_success:
!               wx.TheClipboard.SetData(bmp_obj)
!               wx.TheClipboard.Close()
!               wx.TheClipboard.Flush()
  
      def draw_idle(self):
          """
--- 647,732 ----
          FigureCanvasBase.__init__(self, figure)
          # Set preferred window size hint - helps the sizer (if one is
          # connected)
!         l, b, w, h = figure.bbox.bounds
          w = int(math.ceil(w))
          h = int(math.ceil(h))
  
          wx.Panel.__init__(self, parent, id, size=wx.Size(w, h))
  
          def do_nothing(*args, **kwargs):
!             warnings.warn(
!                 "could not find a setinitialsize function for backend_wx; "
!                 "please report your wxpython version=%s "
!                 "to the matplotlib developers list" %
!                 backend_version)
              pass
  
          # try to find the set size func across wx versions
          try:
              getattr(self, 'SetInitialSize')
          except AttributeError:
!             self.SetInitialSize = getattr(
!                 self,
!                 'SetBestFittingSize',
!                 do_nothing)
! 
!         if not hasattr(self, 'IsShownOnScreen'):
!             self.IsShownOnScreen = getattr(
!                 self,
!                 'IsVisible',
!                 lambda *
!                 args: True)
  
          # Create the drawing bitmap
!         self.bitmap = wxc.EmptyBitmap(w, h)
!         DEBUG_MSG("__init__() - bitmap w:%d h:%d" % (w, h), 2, self)
          # TODO: Add support for 'point' inspection and plot navigation.
          self._isDrawn = False
  
!         self.Bind(wx.EVT_SIZE, self._onSize)
!         self.Bind(wx.EVT_PAINT, self._onPaint)
!         self.Bind(wx.EVT_KEY_DOWN, self._onKeyDown)
!         self.Bind(wx.EVT_KEY_UP, self._onKeyUp)
!         self.Bind(wx.EVT_RIGHT_DOWN, self._onRightButtonDown)
!         self.Bind(wx.EVT_RIGHT_DCLICK, self._onRightButtonDClick)
!         self.Bind(wx.EVT_RIGHT_UP, self._onRightButtonUp)
!         self.Bind(wx.EVT_MOUSEWHEEL, self._onMouseWheel)
!         self.Bind(wx.EVT_LEFT_DOWN, self._onLeftButtonDown)
!         self.Bind(wx.EVT_LEFT_DCLICK, self._onLeftButtonDClick)
!         self.Bind(wx.EVT_LEFT_UP, self._onLeftButtonUp)
!         self.Bind(wx.EVT_MOTION, self._onMotion)
!         self.Bind(wx.EVT_LEAVE_WINDOW, self._onLeave)
!         self.Bind(wx.EVT_ENTER_WINDOW, self._onEnter)
!         self.Bind(wx.EVT_IDLE, self._onIdle)
!         # Add middle button events
!         self.Bind(wx.EVT_MIDDLE_DOWN, self._onMiddleButtonDown)
!         self.Bind(wx.EVT_MIDDLE_DCLICK, self._onMiddleButtonDClick)
!         self.Bind(wx.EVT_MIDDLE_UP, self._onMiddleButtonUp)
! 
!         if wx.VERSION_STRING < "2.9":
!             # only needed in 2.8 to reduce flicker
!             self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
!             self.Bind(wx.EVT_ERASE_BACKGROUND, self._onEraseBackground)
!         else:
!             # this does the same in 2.9+
!             self.SetBackgroundStyle(wx.BG_STYLE_PAINT)
! 
!         self.macros = {}  # dict from wx id to seq of macros
  
      def Destroy(self, *args, **kwargs):
          wx.Panel.Destroy(self, *args, **kwargs)
  
      def Copy_to_Clipboard(self, event=None):
          "copy bitmap of canvas to system clipboard"
          bmp_obj = wx.BitmapDataObject()
          bmp_obj.SetBitmap(self.bitmap)
  
          if not wx.TheClipboard.IsOpened():
!             open_success = wx.TheClipboard.Open()
!             if open_success:
!                 wx.TheClipboard.SetData(bmp_obj)
!                 wx.TheClipboard.Close()
!                 wx.TheClipboard.Flush()
  
      def draw_idle(self):
          """
***************
*** 794,805 ****
          """
          DEBUG_MSG("draw_idle()", 1, self)
          self._isDrawn = False  # Force redraw
!         
          # Triggering a paint event is all that is needed to defer drawing
          # until later. The platform will send the event when it thinks it is
          # a good time (usually as soon as there are no other events pending).
          self.Refresh(eraseBackground=False)
!         
      def draw(self, drawDC=None):
          """
          Render the figure using RendererWx instance renderer, or using a
--- 734,745 ----
          """
          DEBUG_MSG("draw_idle()", 1, self)
          self._isDrawn = False  # Force redraw
! 
          # Triggering a paint event is all that is needed to defer drawing
          # until later. The platform will send the event when it thinks it is
          # a good time (usually as soon as there are no other events pending).
          self.Refresh(eraseBackground=False)
! 
      def draw(self, drawDC=None):
          """
          Render the figure using RendererWx instance renderer, or using a
***************
*** 813,821 ****
  
      def new_timer(self, *args, **kwargs):
          """
!         Creates a new backend-specific subclass of :class:`backend_bases.Timer`.
!         This is useful for getting periodic events through the backend's native
!         event loop. Implemented only for backends with GUIs.
  
          optional arguments:
  
--- 753,762 ----
  
      def new_timer(self, *args, **kwargs):
          """
!         Creates a new backend-specific subclass of
!         :class:`backend_bases.Timer`. This is useful for getting periodic
!         events through the backend's native event loop. Implemented only
!         for backends with GUIs.
  
          optional arguments:
  
***************
*** 853,863 ****
          id = wx.NewId()
          timer = wx.Timer(self, id=id)
          if timeout > 0:
!             timer.Start(timeout*1000, oneShot=True)
!             bind(self, wx.EVT_TIMER, self.stop_event_loop, id=id)
  
          # Event loop handler for start/stop event loop
!         self._event_loop = wx.EventLoop()
          self._event_loop.Run()
          timer.Stop()
  
--- 794,804 ----
          id = wx.NewId()
          timer = wx.Timer(self, id=id)
          if timeout > 0:
!             timer.Start(timeout * 1000, oneShot=True)
!             self.Bind(wx.EVT_TIMER, self.stop_event_loop, id=id)
  
          # Event loop handler for start/stop event loop
!         self._event_loop = wxc.EventLoop()
          self._event_loop.Run()
          timer.Stop()
  
***************
*** 871,888 ****
  
          stop_event_loop_default(self)
          """
!         if hasattr(self,'_event_loop'):
              if self._event_loop.IsRunning():
                  self._event_loop.Exit()
              del self._event_loop
  
- 
      def _get_imagesave_wildcards(self):
          'return the wildcard string for the filesave dialog'
          default_filetype = self.get_default_filetype()
          filetypes = self.get_supported_filetypes_grouped()
!         sorted_filetypes = list(six.iteritems(filetypes))
!         sorted_filetypes.sort()
          wildcards = []
          extensions = []
          filter_index = 0
--- 812,827 ----
  
          stop_event_loop_default(self)
          """
!         if hasattr(self, '_event_loop'):
              if self._event_loop.IsRunning():
                  self._event_loop.Exit()
              del self._event_loop
  
      def _get_imagesave_wildcards(self):
          'return the wildcard string for the filesave dialog'
          default_filetype = self.get_default_filetype()
          filetypes = self.get_supported_filetypes_grouped()
!         sorted_filetypes = sorted(filetypes.items())
          wildcards = []
          extensions = []
          filter_index = 0
***************
*** 896,918 ****
          wildcards = '|'.join(wildcards)
          return wildcards, extensions, filter_index
  
!     def gui_repaint(self, drawDC=None):
          """
          Performs update of the displayed image on the GUI canvas, using the
!         supplied device context.  If drawDC is None, a ClientDC will be used to
!         redraw the image.
          """
          DEBUG_MSG("gui_repaint()", 1, self)
          if self.IsShownOnScreen():
!             if drawDC is None:
!                 drawDC=wx.ClientDC(self)
! 
!             drawDC.BeginDrawing()
!             drawDC.DrawBitmap(self.bitmap, 0, 0)
!             drawDC.EndDrawing()
!             #wx.GetApp().Yield()
!         else:
!             pass
  
      filetypes = FigureCanvasBase.filetypes.copy()
      filetypes['bmp'] = 'Windows bitmap'
--- 835,865 ----
          wildcards = '|'.join(wildcards)
          return wildcards, extensions, filter_index
  
!     def gui_repaint(self, drawDC=None, origin='WX'):
          """
          Performs update of the displayed image on the GUI canvas, using the
!         supplied wx.PaintDC device context.
! 
!         The 'WXAgg' backend sets origin accordingly.
          """
          DEBUG_MSG("gui_repaint()", 1, self)
          if self.IsShownOnScreen():
!             if not drawDC:
!                 # not called from OnPaint use a ClientDC
!                 drawDC = wx.ClientDC(self)
! 
!             # ensure that canvas has no 'left' over stuff when resizing frame
!             drawDC.Clear()
! 
!             # following is for 'WX' backend on Windows
!             # the bitmap can not be in use by another DC,
!             # see GraphicsContextWx._cache
!             if wx.Platform == '__WXMSW__' and origin == 'WX':
!                 img = self.bitmap.ConvertToImage()
!                 bmp = img.ConvertToBitmap()
!                 drawDC.DrawBitmap(bmp, 0, 0)
!             else:
!                 drawDC.DrawBitmap(self.bitmap, 0, 0)
  
      filetypes = FigureCanvasBase.filetypes.copy()
      filetypes['bmp'] = 'Windows bitmap'
***************
*** 939,945 ****
  
      if not _has_pil:
          def print_jpeg(self, filename, *args, **kwargs):
!             return self._print_image(filename, wx.BITMAP_TYPE_JPEG, *args, **kwargs)
          print_jpg = print_jpeg
  
      def print_pcx(self, filename, *args, **kwargs):
--- 886,893 ----
  
      if not _has_pil:
          def print_jpeg(self, filename, *args, **kwargs):
!             return self._print_image(filename, wx.BITMAP_TYPE_JPEG,
!                                      *args, **kwargs)
          print_jpg = print_jpeg
  
      def print_pcx(self, filename, *args, **kwargs):
***************
*** 950,969 ****
  
      if not _has_pil:
          def print_tiff(self, filename, *args, **kwargs):
!             return self._print_image(filename, wx.BITMAP_TYPE_TIF, *args, **kwargs)
          print_tif = print_tiff
  
      def print_xpm(self, filename, *args, **kwargs):
          return self._print_image(filename, wx.BITMAP_TYPE_XPM, *args, **kwargs)
  
      def _print_image(self, filename, filetype, *args, **kwargs):
!         origBitmap   = self.bitmap
  
!         l,b,width,height = self.figure.bbox.bounds
          width = int(math.ceil(width))
          height = int(math.ceil(height))
  
!         self.bitmap = wx.EmptyBitmap(width, height)
          renderer = RendererWx(self.bitmap, self.figure.dpi)
  
          gc = renderer.new_gc()
--- 898,919 ----
  
      if not _has_pil:
          def print_tiff(self, filename, *args, **kwargs):
!             return self._print_image(filename, wx.BITMAP_TYPE_TIF,
!                                      *args, **kwargs)
          print_tif = print_tiff
  
      def print_xpm(self, filename, *args, **kwargs):
          return self._print_image(filename, wx.BITMAP_TYPE_XPM, *args, **kwargs)
  
      def _print_image(self, filename, filetype, *args, **kwargs):
!         origBitmap = self.bitmap
  
!         l, b, width, height = self.figure.bbox.bounds
          width = int(math.ceil(width))
          height = int(math.ceil(height))
  
!         self.bitmap = wxc.EmptyBitmap(width, height)
! 
          renderer = RendererWx(self.bitmap, self.figure.dpi)
  
          gc = renderer.new_gc()
***************
*** 972,997 ****
  
          # image is the object that we call SaveFile on.
          image = self.bitmap
!         # set the JPEG quality appropriately.  Unfortunately, it is only possible
!         # to set the quality on a wx.Image object.  So if we are saving a JPEG,
!         # convert the wx.Bitmap to a wx.Image, and set the quality.
          if filetype == wx.BITMAP_TYPE_JPEG:
!            jpeg_quality = kwargs.get('quality',rcParams['savefig.jpeg_quality'])
!            image = self.bitmap.ConvertToImage()
!            image.SetOption(wx.IMAGE_OPTION_QUALITY,str(jpeg_quality))
  
          # Now that we have rendered into the bitmap, save it
          # to the appropriate file type and clean up
          if is_string_like(filename):
              if not image.SaveFile(filename, filetype):
                  DEBUG_MSG('print_figure() file save error', 4, self)
!                 raise RuntimeError('Could not save figure to %s\n' % (filename))
          elif is_writable_file_like(filename):
!             if not isinstance(image,wx.Image):
!                image = image.ConvertToImage()
              if not image.SaveStream(filename, filetype):
                  DEBUG_MSG('print_figure() file save error', 4, self)
!                 raise RuntimeError('Could not save figure to %s\n' % (filename))
  
          # Restore everything to normal
          self.bitmap = origBitmap
--- 922,953 ----
  
          # image is the object that we call SaveFile on.
          image = self.bitmap
!         # set the JPEG quality appropriately.  Unfortunately, it is only
!         # possible to set the quality on a wx.Image object.  So if we
!         # are saving a JPEG, convert the wx.Bitmap to a wx.Image,
!         # and set the quality.
          if filetype == wx.BITMAP_TYPE_JPEG:
!             jpeg_quality = kwargs.get('quality',
!                                       rcParams['savefig.jpeg_quality'])
!             image = self.bitmap.ConvertToImage()
!             image.SetOption(wx.IMAGE_OPTION_QUALITY, str(jpeg_quality))
  
          # Now that we have rendered into the bitmap, save it
          # to the appropriate file type and clean up
          if is_string_like(filename):
              if not image.SaveFile(filename, filetype):
                  DEBUG_MSG('print_figure() file save error', 4, self)
!                 raise RuntimeError(
!                     'Could not save figure to %s\n' %
!                     (filename))
          elif is_writable_file_like(filename):
!             if not isinstance(image, wx.Image):
!                 image = image.ConvertToImage()
              if not image.SaveStream(filename, filetype):
                  DEBUG_MSG('print_figure() file save error', 4, self)
!                 raise RuntimeError(
!                     'Could not save figure to %s\n' %
!                     (filename))
  
          # Restore everything to normal
          self.bitmap = origBitmap
***************
*** 1036,1049 ****
          DEBUG_MSG("_onSize()", 2, self)
          # Create a new, correctly sized bitmap
          self._width, self._height = self.GetClientSize()
!         self.bitmap =wx.EmptyBitmap(self._width, self._height)
          self._isDrawn = False
  
!         if self._width <= 1 or self._height <= 1: return # Empty figure
  
          dpival = self.figure.dpi
!         winch = self._width/dpival
!         hinch = self._height/dpival
          self.figure.set_size_inches(winch, hinch)
  
          # Rendering will happen on the associated paint event
--- 992,1007 ----
          DEBUG_MSG("_onSize()", 2, self)
          # Create a new, correctly sized bitmap
          self._width, self._height = self.GetClientSize()
!         self.bitmap = wxc.EmptyBitmap(self._width, self._height)
! 
          self._isDrawn = False
  
!         if self._width <= 1 or self._height <= 1:
!             return  # Empty figure
  
          dpival = self.figure.dpi
!         winch = self._width / dpival
!         hinch = self._height / dpival
          self.figure.set_size_inches(winch, hinch)
  
          # Rendering will happen on the associated paint event
***************
*** 1054,1060 ****
  
      def _get_key(self, evt):
  
!         keyval = evt.m_keyCode
          if keyval in self.keyvald:
              key = self.keyvald[keyval]
          elif keyval < 256:
--- 1012,1018 ----
  
      def _get_key(self, evt):
  
!         keyval = evt.KeyCode
          if keyval in self.keyvald:
              key = self.keyvald[keyval]
          elif keyval < 256:
***************
*** 1067,1074 ****
              key = None
  
          for meth, prefix in (
!                              [evt.AltDown, 'alt'],
!                              [evt.ControlDown, 'ctrl'], ):
              if meth():
                  key = '{0}+{1}'.format(prefix, key)
  
--- 1025,1032 ----
              key = None
  
          for meth, prefix in (
!                 [evt.AltDown, 'alt'],
!                 [evt.ControlDown, 'ctrl'], ):
              if meth():
                  key = '{0}+{1}'.format(prefix, key)
  
***************
*** 1088,1094 ****
      def _onKeyUp(self, evt):
          """Release key."""
          key = self._get_key(evt)
!         #print 'release key', key
          evt.Skip()
          FigureCanvasBase.key_release_event(self, key, guiEvent=evt)
  
--- 1046,1052 ----
      def _onKeyUp(self, evt):
          """Release key."""
          key = self._get_key(evt)
!         # print 'release key', key
          evt.Skip()
          FigureCanvasBase.key_release_event(self, key, guiEvent=evt)
  
***************
*** 1106,1119 ****
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
          self.CaptureMouse()
!         FigureCanvasBase.button_press_event(self, x, y, 3, dblclick=True,guiEvent=evt)
  
      def _onRightButtonUp(self, evt):
          """End measuring on an axis."""
          x = evt.GetX()
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
!         if self.HasCapture(): self.ReleaseMouse()
          FigureCanvasBase.button_release_event(self, x, y, 3, guiEvent=evt)
  
      def _onLeftButtonDown(self, evt):
--- 1064,1079 ----
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
          self.CaptureMouse()
!         FigureCanvasBase.button_press_event(self, x, y, 3,
!                                             dblclick=True, guiEvent=evt)
  
      def _onRightButtonUp(self, evt):
          """End measuring on an axis."""
          x = evt.GetX()
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
!         if self.HasCapture():
!             self.ReleaseMouse()
          FigureCanvasBase.button_release_event(self, x, y, 3, guiEvent=evt)
  
      def _onLeftButtonDown(self, evt):
***************
*** 1130,1147 ****
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
          self.CaptureMouse()
!         FigureCanvasBase.button_press_event(self, x, y, 1, dblclick=True, guiEvent=evt)
  
      def _onLeftButtonUp(self, evt):
          """End measuring on an axis."""
          x = evt.GetX()
          y = self.figure.bbox.height - evt.GetY()
!         #print 'release button', 1
          evt.Skip()
!         if self.HasCapture(): self.ReleaseMouse()
          FigureCanvasBase.button_release_event(self, x, y, 1, guiEvent=evt)
  
!     #Add middle button events
      def _onMiddleButtonDown(self, evt):
          """Start measuring on an axis."""
          x = evt.GetX()
--- 1090,1109 ----
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
          self.CaptureMouse()
!         FigureCanvasBase.button_press_event(self, x, y, 1,
!                                             dblclick=True, guiEvent=evt)
  
      def _onLeftButtonUp(self, evt):
          """End measuring on an axis."""
          x = evt.GetX()
          y = self.figure.bbox.height - evt.GetY()
!         # print 'release button', 1
          evt.Skip()
!         if self.HasCapture():
!             self.ReleaseMouse()
          FigureCanvasBase.button_release_event(self, x, y, 1, guiEvent=evt)
  
!     # Add middle button events
      def _onMiddleButtonDown(self, evt):
          """Start measuring on an axis."""
          x = evt.GetX()
***************
*** 1156,1170 ****
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
          self.CaptureMouse()
!         FigureCanvasBase.button_press_event(self, x, y, 2, dblclick=True, guiEvent=evt)
  
      def _onMiddleButtonUp(self, evt):
          """End measuring on an axis."""
          x = evt.GetX()
          y = self.figure.bbox.height - evt.GetY()
!         #print 'release button', 1
          evt.Skip()
!         if self.HasCapture(): self.ReleaseMouse()
          FigureCanvasBase.button_release_event(self, x, y, 2, guiEvent=evt)
  
      def _onMouseWheel(self, evt):
--- 1118,1134 ----
          y = self.figure.bbox.height - evt.GetY()
          evt.Skip()
          self.CaptureMouse()
!         FigureCanvasBase.button_press_event(self, x, y, 2,
!                                             dblclick=True, guiEvent=evt)
  
      def _onMiddleButtonUp(self, evt):
          """End measuring on an axis."""
          x = evt.GetX()
          y = self.figure.bbox.height - evt.GetY()
!         # print 'release button', 1
          evt.Skip()
!         if self.HasCapture():
!             self.ReleaseMouse()
          FigureCanvasBase.button_release_event(self, x, y, 2, guiEvent=evt)
  
      def _onMouseWheel(self, evt):
***************
*** 1178,1185 ****
          delta = evt.GetWheelDelta()
          rotation = evt.GetWheelRotation()
          rate = evt.GetLinesPerAction()
!         #print "delta,rotation,rate",delta,rotation,rate
!         step = rate*float(rotation)/delta
  
          # Done handling event
          evt.Skip()
--- 1142,1149 ----
          delta = evt.GetWheelDelta()
          rotation = evt.GetWheelRotation()
          rate = evt.GetLinesPerAction()
!         # print "delta,rotation,rate",delta,rotation,rate
!         step = rate * float(rotation) / delta
  
          # Done handling event
          evt.Skip()
***************
*** 1187,1193 ****
          # Mac is giving two events for every wheel event
          # Need to skip every second one
          if wx.Platform == '__WXMAC__':
!             if not hasattr(self,'_skipwheelevent'):
                  self._skipwheelevent = True
              elif self._skipwheelevent:
                  self._skipwheelevent = False
--- 1151,1157 ----
          # Mac is giving two events for every wheel event
          # Need to skip every second one
          if wx.Platform == '__WXMAC__':
!             if not hasattr(self, '_skipwheelevent'):
                  self._skipwheelevent = True
              elif self._skipwheelevent:
                  self._skipwheelevent = False
***************
*** 1210,1220 ****
          """Mouse has left the window."""
  
          evt.Skip()
!         FigureCanvasBase.leave_notify_event(self, guiEvent = evt)
  
      def _onEnter(self, evt):
          """Mouse has entered the window."""
!         FigureCanvasBase.enter_notify_event(self, guiEvent = evt)
  
  
  ########################################################################
--- 1174,1184 ----
          """Mouse has left the window."""
  
          evt.Skip()
!         FigureCanvasBase.leave_notify_event(self, guiEvent=evt)
  
      def _onEnter(self, evt):
          """Mouse has entered the window."""
!         FigureCanvasBase.enter_notify_event(self, guiEvent=evt)
  
  
  ########################################################################
***************
*** 1251,1256 ****
--- 1215,1221 ----
          if figManager is not None:
              figManager.canvas.draw_idle()
  
+ 
  class Show(ShowBase):
      def mainloop(self):
          needmain = not wx.App.IsMainLoopRunning()
***************
*** 1261,1266 ****
--- 1226,1232 ----
  
  show = Show()
  
+ 
  def new_figure_manager(num, *args, **kwargs):
      """
      Create a new figure manager instance
***************
*** 1295,1302 ****
          if wx.Platform == '__WXMSW__':
              pos = wx.DefaultPosition
          else:
!             pos =wx.Point(20,20)
!         l,b,w,h = fig.bbox.bounds
          wx.Frame.__init__(self, parent=None, id=-1, pos=pos,
                            title="Figure %d" % num)
          # Frame will be sized later by the Fit method
--- 1261,1268 ----
          if wx.Platform == '__WXMSW__':
              pos = wx.DefaultPosition
          else:
!             pos = wx.Point(20, 20)
!         l, b, w, h = fig.bbox.bounds
          wx.Frame.__init__(self, parent=None, id=-1, pos=pos,
                            title="Figure %d" % num)
          # Frame will be sized later by the Fit method
***************
*** 1308,1314 ****
          self.canvas = self.get_canvas(fig)
          self.canvas.SetInitialSize(wx.Size(fig.bbox.width, fig.bbox.height))
          self.canvas.SetFocus()
!         self.sizer =wx.BoxSizer(wx.VERTICAL)
          self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)
          # By adding toolbar in sizer, we are able to put it at the bottom
          # of the frame - so appearance is closer to GTK version
--- 1274,1280 ----
          self.canvas = self.get_canvas(fig)
          self.canvas.SetInitialSize(wx.Size(fig.bbox.width, fig.bbox.height))
          self.canvas.SetFocus()
!         self.sizer = wx.BoxSizer(wx.VERTICAL)
          self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)
          # By adding toolbar in sizer, we are able to put it at the bottom
          # of the frame - so appearance is closer to GTK version
***************
*** 1332,1350 ****
  
          # give the window a matplotlib icon rather than the stock one.
          # This is not currently working on Linux and is untested elsewhere.
!         #icon_path = os.path.join(matplotlib.rcParams['datapath'],
          #                         'images', 'matplotlib.png')
          #icon = wx.IconFromBitmap(wx.Bitmap(icon_path))
          # for xpm type icons try:
          #icon = wx.Icon(icon_path, wx.BITMAP_TYPE_XPM)
!         #self.SetIcon(icon)
  
          self.figmgr = FigureManagerWx(self.canvas, num, self)
  
!         bind(self, wx.EVT_CLOSE, self._onClose)
  
      def _get_toolbar(self, statbar):
!         if rcParams['toolbar']=='toolbar2':
              toolbar = NavigationToolbar2Wx(self.canvas)
              toolbar.set_status_bar(statbar)
          else:
--- 1298,1316 ----
  
          # give the window a matplotlib icon rather than the stock one.
          # This is not currently working on Linux and is untested elsewhere.
!         # icon_path = os.path.join(matplotlib.rcParams['datapath'],
          #                         'images', 'matplotlib.png')
          #icon = wx.IconFromBitmap(wx.Bitmap(icon_path))
          # for xpm type icons try:
          #icon = wx.Icon(icon_path, wx.BITMAP_TYPE_XPM)
!         # self.SetIcon(icon)
  
          self.figmgr = FigureManagerWx(self.canvas, num, self)
  
!         self.Bind(wx.EVT_CLOSE, self._onClose)
  
      def _get_toolbar(self, statbar):
!         if rcParams['toolbar'] == 'toolbar2':
              toolbar = NavigationToolbar2Wx(self.canvas)
              toolbar.set_status_bar(statbar)
          else:
***************
*** 1363,1369 ****
          self.canvas.close_event()
          self.canvas.stop_event_loop()
          Gcf.destroy(self.num)
!         #self.Destroy()
  
      def GetToolBar(self):
          """Override wxFrame::GetToolBar as we don't have managed toolbar"""
--- 1329,1335 ----
          self.canvas.close_event()
          self.canvas.stop_event_loop()
          Gcf.destroy(self.num)
!         # self.Destroy()
  
      def GetToolBar(self):
          """Override wxFrame::GetToolBar as we don't have managed toolbar"""
***************
*** 1374,1380 ****
              self.canvas.mpl_disconnect(self.toolbar._idDrag)
              # Rationale for line above: see issue 2941338.
          except AttributeError:
!             pass # classic toolbar lacks the attribute
          wx.Frame.Destroy(self, *args, **kwargs)
          if self.toolbar is not None:
              self.toolbar.Destroy()
--- 1340,1346 ----
              self.canvas.mpl_disconnect(self.toolbar._idDrag)
              # Rationale for line above: see issue 2941338.
          except AttributeError:
!             pass  # classic toolbar lacks the attribute
          wx.Frame.Destroy(self, *args, **kwargs)
          if self.toolbar is not None:
              self.toolbar.Destroy()
***************
*** 1394,1401 ****
      public attrs
  
      canvas - a FigureCanvasWx(wx.Panel) instance
!     window - a wxFrame instance - http://www.lpthe.jussieu.fr/~zeitlin/wxWindows/docs/wxwin_wxframe.html#wxframe
      """
      def __init__(self, canvas, num, frame):
          DEBUG_MSG("__init__()", 1, self)
          FigureManagerBase.__init__(self, canvas, num)
--- 1360,1368 ----
      public attrs
  
      canvas - a FigureCanvasWx(wx.Panel) instance
!     window - a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html
      """
+ 
      def __init__(self, canvas, num, frame):
          DEBUG_MSG("__init__()", 1, self)
          FigureManagerBase.__init__(self, canvas, num)
***************
*** 1404,1412 ****
  
          self.tb = frame.GetToolBar()
          self.toolbar = self.tb  # consistent with other backends
          def notify_axes_change(fig):
              'this will be called whenever the current axes is changed'
!             if self.tb != None: self.tb.update()
          self.canvas.figure.add_axobserver(notify_axes_change)
  
      def show(self):
--- 1371,1381 ----
  
          self.tb = frame.GetToolBar()
          self.toolbar = self.tb  # consistent with other backends
+ 
          def notify_axes_change(fig):
              'this will be called whenever the current axes is changed'
!             if self.tb is not None:
!                 self.tb.update()
          self.canvas.figure.add_axobserver(notify_axes_change)
  
      def show(self):
***************
*** 1416,1422 ****
          DEBUG_MSG("destroy()", 1, self)
          self.frame.Destroy()
          #if self.tb is not None: self.tb.Destroy()
!         #wx.GetApp().ProcessIdle()
          wx.WakeUpIdle()
  
      def get_window_title(self):
--- 1385,1391 ----
          DEBUG_MSG("destroy()", 1, self)
          self.frame.Destroy()
          #if self.tb is not None: self.tb.Destroy()
!         # wx.GetApp().ProcessIdle()
          wx.WakeUpIdle()
  
      def get_window_title(self):
***************
*** 1435,1453 ****
  # 'stolen' those from GTK2, and transformed them into the appropriate format.
  #import images_wx
  
! _NTB_AXISMENU        =wx.NewId()
! _NTB_AXISMENU_BUTTON =wx.NewId()
! _NTB_X_PAN_LEFT      =wx.NewId()
! _NTB_X_PAN_RIGHT     =wx.NewId()
! _NTB_X_ZOOMIN        =wx.NewId()
! _NTB_X_ZOOMOUT       =wx.NewId()
! _NTB_Y_PAN_UP        =wx.NewId()
! _NTB_Y_PAN_DOWN      =wx.NewId()
! _NTB_Y_ZOOMIN        =wx.NewId()
! _NTB_Y_ZOOMOUT       =wx.NewId()
  #_NTB_SUBPLOT            =wx.NewId()
! _NTB_SAVE            =wx.NewId()
! _NTB_CLOSE           =wx.NewId()
  
  def _load_bitmap(filename):
      """
--- 1404,1423 ----
  # 'stolen' those from GTK2, and transformed them into the appropriate format.
  #import images_wx
  
! _NTB_AXISMENU = wx.NewId()
! _NTB_AXISMENU_BUTTON = wx.NewId()
! _NTB_X_PAN_LEFT = wx.NewId()
! _NTB_X_PAN_RIGHT = wx.NewId()
! _NTB_X_ZOOMIN = wx.NewId()
! _NTB_X_ZOOMOUT = wx.NewId()
! _NTB_Y_PAN_UP = wx.NewId()
! _NTB_Y_PAN_DOWN = wx.NewId()
! _NTB_Y_ZOOMIN = wx.NewId()
! _NTB_Y_ZOOMOUT = wx.NewId()
  #_NTB_SUBPLOT            =wx.NewId()
! _NTB_SAVE = wx.NewId()
! _NTB_CLOSE = wx.NewId()
! 
  
  def _load_bitmap(filename):
      """
***************
*** 1458,1495 ****
      Returns a wx.Bitmap object
      """
  
!     basedir = os.path.join(rcParams['datapath'],'images')
  
      bmpFilename = os.path.normpath(os.path.join(basedir, filename))
      if not os.path.exists(bmpFilename):
!         raise IOError('Could not find bitmap file "%s"; dying'%bmpFilename)
  
      bmp = wx.Bitmap(bmpFilename)
      return bmp
  
  class MenuButtonWx(wx.Button):
      """
      wxPython does not permit a menu to be incorporated directly into a toolbar.
      This class simulates the effect by associating a pop-up menu with a button
      in the toolbar, and managing this as though it were a menu.
      """
      def __init__(self, parent):
  
          wx.Button.__init__(self, parent, _NTB_AXISMENU_BUTTON, "Axes:        ",
!                           style=wx.BU_EXACTFIT)
          self._toolbar = parent
!         self._menu =wx.Menu()
          self._axisId = []
          # First two menu items never change...
!         self._allId =wx.NewId()
!         self._invertId =wx.NewId()
          self._menu.Append(self._allId, "All", "Select all axes", False)
!         self._menu.Append(self._invertId, "Invert", "Invert axes selected", False)
          self._menu.AppendSeparator()
  
!         bind(self, wx.EVT_BUTTON, self._onMenuButton, id=_NTB_AXISMENU_BUTTON)
!         bind(self, wx.EVT_MENU, self._handleSelectAllAxes, id=self._allId)
!         bind(self, wx.EVT_MENU, self._handleInvertAxesSelected, id=self._invertId)
  
      def Destroy(self):
          self._menu.Destroy()
--- 1428,1474 ----
      Returns a wx.Bitmap object
      """
  
!     basedir = os.path.join(rcParams['datapath'], 'images')
  
      bmpFilename = os.path.normpath(os.path.join(basedir, filename))
      if not os.path.exists(bmpFilename):
!         raise IOError('Could not find bitmap file "%s"; dying' % bmpFilename)
  
      bmp = wx.Bitmap(bmpFilename)
      return bmp
  
+ 
  class MenuButtonWx(wx.Button):
      """
      wxPython does not permit a menu to be incorporated directly into a toolbar.
      This class simulates the effect by associating a pop-up menu with a button
      in the toolbar, and managing this as though it were a menu.
      """
+ 
      def __init__(self, parent):
  
          wx.Button.__init__(self, parent, _NTB_AXISMENU_BUTTON, "Axes:        ",
!                            style=wx.BU_EXACTFIT)
          self._toolbar = parent
!         self._menu = wx.Menu()
          self._axisId = []
          # First two menu items never change...
!         self._allId = wx.NewId()
!         self._invertId = wx.NewId()
          self._menu.Append(self._allId, "All", "Select all axes", False)
!         self._menu.Append(
!             self._invertId,
!             "Invert",
!             "Invert axes selected",
!             False)
          self._menu.AppendSeparator()
  
!         self.Bind(wx.EVT_BUTTON, self._onMenuButton, id=_NTB_AXISMENU_BUTTON)
!         self.Bind(wx.EVT_MENU, self._handleSelectAllAxes, id=self._allId)
!         self.Bind(
!             wx.EVT_MENU,
!             self._handleInvertAxesSelected,
!             id=self._invertId)
  
      def Destroy(self):
          self._menu.Destroy()
***************
*** 1499,1506 ****
          """Handle menu button pressed."""
          x, y = self.GetPositionTuple()
          w, h = self.GetSizeTuple()
!         self.PopupMenuXY(self._menu, x, y+h-4)
!                 # When menu returned, indicate selection in button
          evt.Skip()
  
      def _handleSelectAllAxes(self, evt):
--- 1478,1485 ----
          """Handle menu button pressed."""
          x, y = self.GetPositionTuple()
          w, h = self.GetSizeTuple()
!         self.PopupMenuXY(self._menu, x, y + h - 4)
!         # When menu returned, indicate selection in button
          evt.Skip()
  
      def _handleSelectAllAxes(self, evt):
***************
*** 1514,1520 ****
  
      def _handleInvertAxesSelected(self, evt):
          """Called when the invert all menu item is selected"""
!         if len(self._axisId) == 0: return
          for i in range(len(self._axisId)):
              if self._menu.IsChecked(self._axisId[i]):
                  self._menu.Check(self._axisId[i], False)
--- 1493,1500 ----
  
      def _handleInvertAxesSelected(self, evt):
          """Called when the invert all menu item is selected"""
!         if len(self._axisId) == 0:
!             return
          for i in range(len(self._axisId)):
              if self._menu.IsChecked(self._axisId[i]):
                  self._menu.Check(self._axisId[i], False)
***************
*** 1541,1551 ****
          (selected by default)."""
          if maxAxis > len(self._axisId):
              for i in range(len(self._axisId) + 1, maxAxis + 1, 1):
!                 menuId =wx.NewId()
                  self._axisId.append(menuId)
!                 self._menu.Append(menuId, "Axis %d" % i, "Select axis %d" % i, True)
                  self._menu.Check(menuId, True)
!                 bind(self, wx.EVT_MENU, self._onMenuItemSelected, id=menuId)
          elif maxAxis < len(self._axisId):
              for menuId in self._axisId[maxAxis:]:
                  self._menu.Delete(menuId)
--- 1521,1537 ----
          (selected by default)."""
          if maxAxis > len(self._axisId):
              for i in range(len(self._axisId) + 1, maxAxis + 1, 1):
!                 menuId = wx.NewId()
                  self._axisId.append(menuId)
!                 self._menu.Append(
!                     menuId,
!                     "Axis %d" %
!                     i,
!                     "Select axis %d" %
!                     i,
!                     True)
                  self._menu.Check(menuId, True)
!                 self.Bind(wx.EVT_MENU, self._onMenuItemSelected, id=menuId)
          elif maxAxis < len(self._axisId):
              for menuId in self._axisId[maxAxis:]:
                  self._menu.Delete(menuId)
***************
*** 1564,1587 ****
          """Update the list of selected axes in the menu button"""
          axis_txt = ''
          for e in lst:
!             axis_txt += '%d,' % (e+1)
          # remove trailing ',' and add to button string
          self.SetLabel("Axes: %s" % axis_txt[:-1])
  
  
  cursord = {
!     cursors.MOVE : wx.CURSOR_HAND,
!     cursors.HAND : wx.CURSOR_HAND,
!     cursors.POINTER : wx.CURSOR_ARROW,
!     cursors.SELECT_REGION : wx.CURSOR_CROSS,
!     }
  
  
  class SubplotToolWX(wx.Frame):
      def __init__(self, targetfig):
          wx.Frame.__init__(self, None, -1, "Configure subplots")
  
!         toolfig = Figure((6,3))
          canvas = FigureCanvasWx(self, -1, toolfig)
  
          # Create a figure manager to manage things
--- 1550,1573 ----
          """Update the list of selected axes in the menu button"""
          axis_txt = ''
          for e in lst:
!             axis_txt += '%d,' % (e + 1)
          # remove trailing ',' and add to button string
          self.SetLabel("Axes: %s" % axis_txt[:-1])
  
  
  cursord = {
!     cursors.MOVE: wx.CURSOR_HAND,
!     cursors.HAND: wx.CURSOR_HAND,
!     cursors.POINTER: wx.CURSOR_ARROW,
!     cursors.SELECT_REGION: wx.CURSOR_CROSS,
! }
  
  
  class SubplotToolWX(wx.Frame):
      def __init__(self, targetfig):
          wx.Frame.__init__(self, None, -1, "Configure subplots")
  
!         toolfig = Figure((6, 3))
          canvas = FigureCanvasWx(self, -1, toolfig)
  
          # Create a figure manager to manage things
***************
*** 1590,1603 ****
          # Now put all into a sizer
          sizer = wx.BoxSizer(wx.VERTICAL)
          # This way of adding to sizer allows resizing
!         sizer.Add(canvas, 1, wx.LEFT|wx.TOP|wx.GROW)
          self.SetSizer(sizer)
          self.Fit()
          tool = SubplotTool(targetfig, toolfig)
  
  
  class NavigationToolbar2Wx(NavigationToolbar2, wx.ToolBar):
- 
      def __init__(self, canvas):
          wx.ToolBar.__init__(self, canvas.GetParent(), -1)
          NavigationToolbar2.__init__(self, canvas)
--- 1576,1588 ----
          # Now put all into a sizer
          sizer = wx.BoxSizer(wx.VERTICAL)
          # This way of adding to sizer allows resizing
!         sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW)
          self.SetSizer(sizer)
          self.Fit()
          tool = SubplotTool(targetfig, toolfig)
  
  
  class NavigationToolbar2Wx(NavigationToolbar2, wx.ToolBar):
      def __init__(self, canvas):
          wx.ToolBar.__init__(self, canvas.GetParent(), -1)
          NavigationToolbar2.__init__(self, canvas)
***************
*** 1613,1632 ****
  
          self._parent = self.canvas.GetParent()
  
- 
          self.wx_ids = {}
          for text, tooltip_text, image_file, callback in self.toolitems:
              if text is None:
                  self.AddSeparator()
                  continue
              self.wx_ids[text] = wx.NewId()
!             if text in ['Pan', 'Zoom']:
!                self.AddCheckTool(self.wx_ids[text], _load_bitmap(image_file + '.png'),
!                                  shortHelp=text, longHelp=tooltip_text)
!             else:
!                self.AddSimpleTool(self.wx_ids[text], _load_bitmap(image_file + '.png'),
!                                   text, tooltip_text)
!             bind(self, wx.EVT_TOOL, getattr(self, callback), id=self.wx_ids[text])
  
          self.Realize()
  
--- 1598,1615 ----
  
          self._parent = self.canvas.GetParent()
  
          self.wx_ids = {}
          for text, tooltip_text, image_file, callback in self.toolitems:
              if text is None:
                  self.AddSeparator()
                  continue
              self.wx_ids[text] = wx.NewId()
!             wxc.AddTool(self, self.wx_ids, text,
!                         _load_bitmap(image_file + '.png'),
!                         tooltip_text)
! 
!             self.Bind(wx.EVT_TOOL, getattr(self, callback),
!                       id=self.wx_ids[text])
  
          self.Realize()
  
***************
*** 1641,1647 ****
      def configure_subplots(self, evt):
          frame = wx.Frame(None, -1, "Configure subplots")
  
!         toolfig = Figure((6,3))
          canvas = self.get_canvas(frame, toolfig)
  
          # Create a figure manager to manage things
--- 1624,1630 ----
      def configure_subplots(self, evt):
          frame = wx.Frame(None, -1, "Configure subplots")
  
!         toolfig = Figure((6, 3))
          canvas = self.get_canvas(frame, toolfig)
  
          # Create a figure manager to manage things
***************
*** 1650,1656 ****
          # Now put all into a sizer
          sizer = wx.BoxSizer(wx.VERTICAL)
          # This way of adding to sizer allows resizing
!         sizer.Add(canvas, 1, wx.LEFT|wx.TOP|wx.GROW)
          frame.SetSizer(sizer)
          frame.Fit()
          tool = SubplotTool(self.canvas.figure, toolfig)
--- 1633,1639 ----
          # Now put all into a sizer
          sizer = wx.BoxSizer(wx.VERTICAL)
          # This way of adding to sizer allows resizing
!         sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW)
          frame.SetSizer(sizer)
          frame.Fit()
          tool = SubplotTool(self.canvas.figure, toolfig)
***************
*** 1662,1681 ****
          default_file = self.canvas.get_default_filename()
          dlg = wx.FileDialog(self._parent, "Save to file", "", default_file,
                              filetypes,
!                             wx.SAVE|wx.OVERWRITE_PROMPT)
          dlg.SetFilterIndex(filter_index)
          if dlg.ShowModal() == wx.ID_OK:
!             dirname  = dlg.GetDirectory()
              filename = dlg.GetFilename()
!             DEBUG_MSG('Save file dir:%s name:%s' % (dirname, filename), 3, self)
              format = exts[dlg.GetFilterIndex()]
              basename, ext = os.path.splitext(filename)
              if ext.startswith('.'):
                  ext = ext[1:]
!             if ext in ('svg', 'pdf', 'ps', 'eps', 'png') and format!=ext:
!                 #looks like they forgot to set the image type drop
!                 #down, going with the extension.
!                 warnings.warn('extension %s did not match the selected image type %s; going with %s'%(ext, format, ext), stacklevel=0)
                  format = ext
              try:
                  self.canvas.print_figure(
--- 1645,1669 ----
          default_file = self.canvas.get_default_filename()
          dlg = wx.FileDialog(self._parent, "Save to file", "", default_file,
                              filetypes,
!                             wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
          dlg.SetFilterIndex(filter_index)
          if dlg.ShowModal() == wx.ID_OK:
!             dirname = dlg.GetDirectory()
              filename = dlg.GetFilename()
!             DEBUG_MSG(
!                 'Save file dir:%s name:%s' %
!                 (dirname, filename), 3, self)
              format = exts[dlg.GetFilterIndex()]
              basename, ext = os.path.splitext(filename)
              if ext.startswith('.'):
                  ext = ext[1:]
!             if ext in ('svg', 'pdf', 'ps', 'eps', 'png') and format != ext:
!                 # looks like they forgot to set the image type drop
!                 # down, going with the extension.
!                 warnings.warn(
!                     'extension %s did not match the selected '
!                     'image type %s; going with %s' %
!                     (ext, format, ext), stacklevel=0)
                  format = ext
              try:
                  self.canvas.print_figure(
***************
*** 1684,1695 ****
                  error_msg_wx(str(e))
  
      def set_cursor(self, cursor):
!         cursor =wx.StockCursor(cursord[cursor])
!         self.canvas.SetCursor( cursor )
  
      def release(self, event):
!         try: del self.lastrect
!         except AttributeError: pass
  
      def dynamic_update(self):
          d = self._idle
--- 1672,1685 ----
                  error_msg_wx(str(e))
  
      def set_cursor(self, cursor):
!         cursor = wxc.Cursor(cursord[cursor])
!         self.canvas.SetCursor(cursor)
  
      def release(self, event):
!         try:
!             del self.lastrect
!         except AttributeError:
!             pass
  
      def dynamic_update(self):
          d = self._idle
***************
*** 1726,1756 ****
          y1 = height - y1
          y0 = height - y0
  
!         if y1<y0: y0, y1 = y1, y0
!         if x1<y0: x0, x1 = x1, x0
  
          w = x1 - x0
          h = y1 - y0
          rect = wx.Rect(x0, y0, w, h)
  
!         rubberBandColor = '#C0C0FF' # or load from config?
  
          # Set a pen for the border
          color = wx.NamedColour(rubberBandColor)
          dc.SetPen(wx.Pen(color, 1))
  
          # use the same color, plus alpha for the brush
!         r, g, b = color.Get()
!         color.Set(r,g,b, 0x60)
          dc.SetBrush(wx.Brush(color))
          dc.DrawRectangleRect(rect)
-         
  
      def set_status_bar(self, statbar):
          self.statbar = statbar
  
      def set_message(self, s):
!         if self.statbar is not None: self.statbar.set_function(s)
  
      def set_history_buttons(self):
          can_backward = (self._views._pos > 0)
--- 1716,1748 ----
          y1 = height - y1
          y0 = height - y0
  
!         if y1 < y0:
!             y0, y1 = y1, y0
!         if x1 < y0:
!             x0, x1 = x1, x0
  
          w = x1 - x0
          h = y1 - y0
          rect = wx.Rect(x0, y0, w, h)
  
!         rubberBandColor = '#C0C0FF'  # or load from config?
  
          # Set a pen for the border
          color = wx.NamedColour(rubberBandColor)
          dc.SetPen(wx.Pen(color, 1))
  
          # use the same color, plus alpha for the brush
!         r, g, b, a = color.Get(True)
!         color.Set(r, g, b, 0x60)
          dc.SetBrush(wx.Brush(color))
          dc.DrawRectangleRect(rect)
  
      def set_status_bar(self, statbar):
          self.statbar = statbar
  
      def set_message(self, s):
!         if self.statbar is not None:
!             self.statbar.set_function(s)
  
      def set_history_buttons(self):
          can_backward = (self._views._pos > 0)
***************
*** 1765,1800 ****
      previously selected scroll function to be displayed as a user
      convenience.
      """
      def __init__(self, parent):
          wx.StatusBar.__init__(self, parent, -1)
          self.SetFieldsCount(2)
          self.SetStatusText("None", 1)
          #self.SetStatusText("Measurement: None", 2)
!         #self.Reposition()
  
      def set_function(self, string):
          self.SetStatusText("%s" % string, 1)
  
!     #def set_measurement(self, string):
      #    self.SetStatusText("Measurement: %s" % string, 2)
  
  
  #< Additions for printing support: Matt Newville
  
  class PrintoutWx(wx.Printout):
!     """Simple wrapper around wx Printout class -- all the real work
      here is scaling the matplotlib canvas bitmap to the current
      printer's definition.
      """
!     def __init__(self, canvas, width=5.5,margin=0.5, title='matplotlib'):
!         wx.Printout.__init__(self,title=title)
          self.canvas = canvas
          # width, in inches of output figure (approximate)
!         self.width  = width
          self.margin = margin
  
      def HasPage(self, page):
!         #current only supports 1 page print
          return page == 1
  
      def GetPageInfo(self):
--- 1757,1795 ----
      previously selected scroll function to be displayed as a user
      convenience.
      """
+ 
      def __init__(self, parent):
          wx.StatusBar.__init__(self, parent, -1)
          self.SetFieldsCount(2)
          self.SetStatusText("None", 1)
          #self.SetStatusText("Measurement: None", 2)
!         # self.Reposition()
  
      def set_function(self, string):
          self.SetStatusText("%s" % string, 1)
  
!     # def set_measurement(self, string):
      #    self.SetStatusText("Measurement: %s" % string, 2)
  
  
  #< Additions for printing support: Matt Newville
  
  class PrintoutWx(wx.Printout):
!     """
!     Simple wrapper around wx Printout class -- all the real work
      here is scaling the matplotlib canvas bitmap to the current
      printer's definition.
      """
! 
!     def __init__(self, canvas, width=5.5, margin=0.5, title='matplotlib'):
!         wx.Printout.__init__(self, title=title)
          self.canvas = canvas
          # width, in inches of output figure (approximate)
!         self.width = width
          self.margin = margin
  
      def HasPage(self, page):
!         # current only supports 1 page print
          return page == 1
  
      def GetPageInfo(self):
***************
*** 1803,1847 ****
      def OnPrintPage(self, page):
          self.canvas.draw()
  
!         dc        = self.GetDC()
!         (ppw,pph) = self.GetPPIPrinter()      # printer's pixels per in
!         (pgw,pgh) = self.GetPageSizePixels()  # page size in pixels
!         (dcw,dch) = dc.GetSize()
!         (grw,grh) = self.canvas.GetSizeTuple()
  
          # save current figure dpi resolution and bg color,
          # so that we can temporarily set them to the dpi of
          # the printer, and the bg color to white
!         bgcolor   = self.canvas.figure.get_facecolor()
!         fig_dpi   = self.canvas.figure.dpi
  
          # draw the bitmap, scaled appropriately
!         vscale    = float(ppw) / fig_dpi
  
          # set figure resolution,bg color for printer
          self.canvas.figure.dpi = ppw
          self.canvas.figure.set_facecolor('#FFFFFF')
  
!         renderer  = RendererWx(self.canvas.bitmap, self.canvas.figure.dpi)
          self.canvas.figure.draw(renderer)
!         self.canvas.bitmap.SetWidth(  int(self.canvas.bitmap.GetWidth() * vscale))
!         self.canvas.bitmap.SetHeight( int(self.canvas.bitmap.GetHeight()* vscale))
          self.canvas.draw()
  
          # page may need additional scaling on preview
          page_scale = 1.0
!         if self.IsPreview():   page_scale = float(dcw)/pgw
  
          # get margin in pixels = (margin in in) * (pixels/in)
!         top_margin  = int(self.margin * pph * page_scale)
          left_margin = int(self.margin * ppw * page_scale)
  
          # set scale so that width of output is self.width inches
          # (assuming grw is size of graph in inches....)
!         user_scale = (self.width * fig_dpi * page_scale)/float(grw)
  
!         dc.SetDeviceOrigin(left_margin,top_margin)
!         dc.SetUserScale(user_scale,user_scale)
  
          # this cute little number avoid API inconsistencies in wx
          try:
--- 1798,1845 ----
      def OnPrintPage(self, page):
          self.canvas.draw()
  
!         dc = self.GetDC()
!         (ppw, pph) = self.GetPPIPrinter()      # printer's pixels per in
!         (pgw, pgh) = self.GetPageSizePixels()  # page size in pixels
!         (dcw, dch) = dc.GetSize()
!         (grw, grh) = self.canvas.GetSizeTuple()
  
          # save current figure dpi resolution and bg color,
          # so that we can temporarily set them to the dpi of
          # the printer, and the bg color to white
!         bgcolor = self.canvas.figure.get_facecolor()
!         fig_dpi = self.canvas.figure.dpi
  
          # draw the bitmap, scaled appropriately
!         vscale = float(ppw) / fig_dpi
  
          # set figure resolution,bg color for printer
          self.canvas.figure.dpi = ppw
          self.canvas.figure.set_facecolor('#FFFFFF')
  
!         renderer = RendererWx(self.canvas.bitmap, self.canvas.figure.dpi)
          self.canvas.figure.draw(renderer)
!         self.canvas.bitmap.SetWidth(
!             int(self.canvas.bitmap.GetWidth() * vscale))
!         self.canvas.bitmap.SetHeight(
!             int(self.canvas.bitmap.GetHeight() * vscale))
          self.canvas.draw()
  
          # page may need additional scaling on preview
          page_scale = 1.0
!         if self.IsPreview():
!             page_scale = float(dcw) / pgw
  
          # get margin in pixels = (margin in in) * (pixels/in)
!         top_margin = int(self.margin * pph * page_scale)
          left_margin = int(self.margin * ppw * page_scale)
  
          # set scale so that width of output is self.width inches
          # (assuming grw is size of graph in inches....)
!         user_scale = (self.width * fig_dpi * page_scale) / float(grw)
  
!         dc.SetDeviceOrigin(left_margin, top_margin)
!         dc.SetUserScale(user_scale, user_scale)
  
          # this cute little number avoid API inconsistencies in wx
          try:
*** matplotlib/backends/backend_wxagg.py.orig	Tue Dec 23 15:04:40 2014
--- matplotlib/backends/backend_wxagg.py	Tue Mar 17 11:42:57 2015
***************
*** 7,16 ****
  from matplotlib.figure import Figure
  
  from .backend_agg import FigureCanvasAgg
! from . import backend_wx    # already uses wxversion.ensureMinimal('2.8')
  from .backend_wx import FigureManagerWx, FigureCanvasWx, \
      FigureFrameWx, DEBUG_MSG, NavigationToolbar2Wx, error_msg_wx, \
!     draw_if_interactive, show, Toolbar, backend_version
  import wx
  
  
--- 7,19 ----
  from matplotlib.figure import Figure
  
  from .backend_agg import FigureCanvasAgg
! 
! from . import wx_compat as wxc
! from . import backend_wx
  from .backend_wx import FigureManagerWx, FigureCanvasWx, \
      FigureFrameWx, DEBUG_MSG, NavigationToolbar2Wx, error_msg_wx, \
!     draw_if_interactive, show, Toolbar
! 
  import wx
  
  
***************
*** 19,25 ****
          return FigureCanvasWxAgg(self, -1, fig)
  
      def _get_toolbar(self, statbar):
!         if matplotlib.rcParams['toolbar']=='toolbar2':
              toolbar = NavigationToolbar2WxAgg(self.canvas)
              toolbar.set_status_bar(statbar)
          else:
--- 22,28 ----
          return FigureCanvasWxAgg(self, -1, fig)
  
      def _get_toolbar(self, statbar):
!         if matplotlib.rcParams['toolbar'] == 'toolbar2':
              toolbar = NavigationToolbar2WxAgg(self.canvas)
              toolbar.set_status_bar(statbar)
          else:
***************
*** 47,53 ****
  
          self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)
          self._isDrawn = True
!         self.gui_repaint(drawDC=drawDC)
  
      def blit(self, bbox=None):
          """
--- 50,56 ----
  
          self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)
          self._isDrawn = True
!         self.gui_repaint(drawDC=drawDC, origin='WXAgg')
  
      def blit(self, bbox=None):
          """
***************
*** 72,80 ****
          destDC = wx.MemoryDC()
          destDC.SelectObject(self.bitmap)
  
-         destDC.BeginDrawing()
          destDC.Blit(x, y, int(w), int(h), srcDC, x, y)
-         destDC.EndDrawing()
  
          destDC.SelectObject(wx.NullBitmap)
          srcDC.SelectObject(wx.NullBitmap)
--- 75,81 ----
***************
*** 112,117 ****
--- 113,119 ----
  
      return new_figure_manager_given_figure(num, fig)
  
+ 
  def new_figure_manager_given_figure(num, figure):
      """
      Create a new figure manager instance for the given figure.
***************
*** 136,142 ****
      """
      if bbox is None:
          # agg => rgb -> image
!         image = wx.EmptyImage(int(agg.width), int(agg.height))
          image.SetData(agg.tostring_rgb())
          return image
      else:
--- 138,144 ----
      """
      if bbox is None:
          # agg => rgb -> image
!         image = wxc.EmptyImage(int(agg.width), int(agg.height))
          image.SetData(agg.tostring_rgb())
          return image
      else:
***************
*** 153,160 ****
      """
      if bbox is None:
          # agg => rgba buffer -> bitmap
!         return wx.BitmapFromBufferRGBA(int(agg.width), int(agg.height),
!             agg.buffer_rgba())
      else:
          # agg => rgba buffer -> bitmap => clipped bitmap
          return _WX28_clipped_agg_as_bitmap(agg, bbox)
--- 155,162 ----
      """
      if bbox is None:
          # agg => rgba buffer -> bitmap
!         return wxc.BitmapFromBuffer(int(agg.width), int(agg.height),
!                                     agg.buffer_rgba())
      else:
          # agg => rgba buffer -> bitmap => clipped bitmap
          return _WX28_clipped_agg_as_bitmap(agg, bbox)
***************
*** 170,189 ****
      r = l + width
      t = b + height
  
!     srcBmp = wx.BitmapFromBufferRGBA(int(agg.width), int(agg.height),
!         agg.buffer_rgba())
      srcDC = wx.MemoryDC()
      srcDC.SelectObject(srcBmp)
  
!     destBmp = wx.EmptyBitmap(int(width), int(height))
      destDC = wx.MemoryDC()
      destDC.SelectObject(destBmp)
  
-     destDC.BeginDrawing()
      x = int(l)
      y = int(int(agg.height) - t)
      destDC.Blit(0, 0, int(width), int(height), srcDC, x, y)
-     destDC.EndDrawing()
  
      srcDC.SelectObject(wx.NullBitmap)
      destDC.SelectObject(wx.NullBitmap)
--- 172,189 ----
      r = l + width
      t = b + height
  
!     srcBmp = wxc.BitmapFromBuffer(int(agg.width), int(agg.height),
!                                   agg.buffer_rgba())
      srcDC = wx.MemoryDC()
      srcDC.SelectObject(srcBmp)
  
!     destBmp = wxc.EmptyBitmap(int(width), int(height))
      destDC = wx.MemoryDC()
      destDC.SelectObject(destBmp)
  
      x = int(l)
      y = int(int(agg.height) - t)
      destDC.Blit(0, 0, int(width), int(height), srcDC, x, y)
  
      srcDC.SelectObject(wx.NullBitmap)
      destDC.SelectObject(wx.NullBitmap)
*** matplotlib/backends/wx_compat.py.orig	Tue Mar 17 11:50:07 2015
--- matplotlib/backends/wx_compat.py	Tue Mar 17 11:43:24 2015
***************
*** 0 ****
--- 1,162 ----
+ #!/usr/bin/env python
+ """
+ A wx API adapter to hide differences between wxPython classic and phoenix.
+ 
+ It is assumed that the user code is selecting what version it wants to use,
+ here we just ensure that it meets the minimum required by matplotlib.
+ 
+ For an example see embedding_in_wx2.py
+ """
+ from __future__ import (absolute_import, division, print_function,
+                         unicode_literals)
+ 
+ import six
+ 
+ missingwx = "Matplotlib backend_wx and backend_wxagg require wxPython >=2.8"
+ 
+ 
+ try:
+     import wx
+     backend_version = wx.VERSION_STRING
+     is_phoenix = 'phoenix' in wx.PlatformInfo
+ except ImportError:
+     raise ImportError(missingwx)
+ 
+ # Ensure we have the correct version imported
+ major, minor = [int(n) for n in backend_version.split('.')[:2]]
+ if major < 2 or (major < 3 and minor < 8):
+     print(" wxPython version %s was imported." % backend_version)
+     raise ImportError(missingwx)
+ 
+ if is_phoenix:
+     # define all the wxPython phoenix stuff
+ 
+     # font styles, families and weight
+     fontweights = {
+         100: wx.FONTWEIGHT_LIGHT,
+         200: wx.FONTWEIGHT_LIGHT,
+         300: wx.FONTWEIGHT_LIGHT,
+         400: wx.FONTWEIGHT_NORMAL,
+         500: wx.FONTWEIGHT_NORMAL,
+         600: wx.FONTWEIGHT_NORMAL,
+         700: wx.FONTWEIGHT_BOLD,
+         800: wx.FONTWEIGHT_BOLD,
+         900: wx.FONTWEIGHT_BOLD,
+         'ultralight': wx.FONTWEIGHT_LIGHT,
+         'light': wx.FONTWEIGHT_LIGHT,
+         'normal': wx.FONTWEIGHT_NORMAL,
+         'medium': wx.FONTWEIGHT_NORMAL,
+         'semibold': wx.FONTWEIGHT_NORMAL,
+         'bold': wx.FONTWEIGHT_BOLD,
+         'heavy': wx.FONTWEIGHT_BOLD,
+         'ultrabold': wx.FONTWEIGHT_BOLD,
+         'black': wx.FONTWEIGHT_BOLD
+     }
+     fontangles = {
+         'italic': wx.FONTSTYLE_ITALIC,
+         'normal': wx.FONTSTYLE_NORMAL,
+         'oblique': wx.FONTSTYLE_SLANT}
+ 
+     # wxPython allows for portable font styles, choosing them appropriately
+     # for the target platform. Map some standard font names to the portable
+     # styles
+     # QUESTION: Is it be wise to agree standard fontnames across all backends?
+     fontnames = {'Sans': wx.FONTFAMILY_SWISS,
+                  'Roman': wx.FONTFAMILY_ROMAN,
+                  'Script': wx.FONTFAMILY_SCRIPT,
+                  'Decorative': wx.FONTFAMILY_DECORATIVE,
+                  'Modern': wx.FONTFAMILY_MODERN,
+                  'Courier': wx.FONTFAMILY_MODERN,
+                  'courier': wx.FONTFAMILY_MODERN}
+ 
+     dashd_wx = {'solid': wx.PENSTYLE_SOLID,
+                 'dashed': wx.PENSTYLE_SHORT_DASH,
+                 'dashdot': wx.PENSTYLE_DOT_DASH,
+                 'dotted': wx.PENSTYLE_DOT}
+ 
+     # functions changes
+     BitmapFromBuffer = wx.Bitmap.FromBufferRGBA
+     EmptyBitmap = wx.Bitmap
+     EmptyImage = wx.Image
+     Cursor = wx.Cursor
+     EventLoop = wx.GUIEventLoop
+     NamedColour = wx.Colour
+     StockCursor = wx.Cursor
+ 
+ else:
+     # define all the wxPython classic stuff
+ 
+     # font styles, families and weight
+     fontweights = {
+         100: wx.LIGHT,
+         200: wx.LIGHT,
+         300: wx.LIGHT,
+         400: wx.NORMAL,
+         500: wx.NORMAL,
+         600: wx.NORMAL,
+         700: wx.BOLD,
+         800: wx.BOLD,
+         900: wx.BOLD,
+         'ultralight': wx.LIGHT,
+         'light': wx.LIGHT,
+         'normal': wx.NORMAL,
+         'medium': wx.NORMAL,
+         'semibold': wx.NORMAL,
+         'bold': wx.BOLD,
+         'heavy': wx.BOLD,
+         'ultrabold': wx.BOLD,
+         'black': wx.BOLD
+     }
+     fontangles = {
+         'italic': wx.ITALIC,
+         'normal': wx.NORMAL,
+         'oblique': wx.SLANT}
+ 
+     # wxPython allows for portable font styles, choosing them appropriately
+     # for the target platform. Map some standard font names to the portable
+     # styles
+     # QUESTION: Is it be wise to agree standard fontnames across all backends?
+     fontnames = {'Sans': wx.SWISS,
+                  'Roman': wx.ROMAN,
+                  'Script': wx.SCRIPT,
+                  'Decorative': wx.DECORATIVE,
+                  'Modern': wx.MODERN,
+                  'Courier': wx.MODERN,
+                  'courier': wx.MODERN}
+ 
+     dashd_wx = {'solid': wx.SOLID,
+                 'dashed': wx.SHORT_DASH,
+                 'dashdot': wx.DOT_DASH,
+                 'dotted': wx.DOT}
+ 
+     # functions changes
+     BitmapFromBuffer = wx.BitmapFromBufferRGBA
+     EmptyBitmap = wx.EmptyBitmap
+     EmptyImage = wx.EmptyImage
+     Cursor = wx.StockCursor
+     EventLoop = wx.EventLoop
+     NamedColour = wx.NamedColour
+     StockCursor = wx.StockCursor
+ 
+ 
+ def AddTool(parent, wx_ids, text, bmp, tooltip_text):
+     if is_phoenix:
+         if text in ['Pan', 'Zoom']:
+             kind = wx.ITEM_CHECK
+         else:
+             kind = wx.ITEM_NORMAL
+         parent.AddTool(wx_ids[text], label=text,
+                        bitmap=bmp,
+                        bmpDisabled=wx.NullBitmap,
+                        shortHelpString=text,
+                        longHelpString=tooltip_text,
+                        kind=kind)
+     else:
+         if text in ['Pan', 'Zoom']:
+             parent.AddCheckTool(
+                 wx_ids[text],
+                 bmp,
+                 shortHelp=text,
+                 longHelp=tooltip_text)
+         else:
+             parent.AddSimpleTool(wx_ids[text], bmp, text, tooltip_text)
