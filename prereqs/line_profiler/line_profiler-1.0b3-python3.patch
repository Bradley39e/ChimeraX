diff -u -r line_profiler-1.0b3/kernprof.py line_profiler/kernprof.py
--- line_profiler-1.0b3/kernprof.py	2011-09-19 20:36:54.000000000 -0700
+++ line_profiler/kernprof.py	2014-01-16 13:20:39.995338387 -0800
@@ -8,8 +8,8 @@
 import sys
 
 
-# Guard the import of cProfile such that 2.4 people without lsprof can still use
-# this script.
+# Guard the import of cProfile such that 3.x people
+# without lsprof can still use this script.
 try:
     from cProfile import Profile
 except ImportError:
@@ -19,40 +19,29 @@
         from profile import Profile
 
 
++# Python 3.x compatibility utils: execfile
++# ========================================
+try:
+    execfile
+except NameError:
+    # Python 3.x doesn't have 'execfile' builtin
+    import builtins
+    exec_ = getattr(builtins, "exec")
+
+    def execfile(filename, globals=None, locals=None):
+        with open(filename) as f:
+            exec_(compile(f.read(), filename, 'exec'), globals, locals)
+# =====================================
+
+
+
 CO_GENERATOR = 0x0020
 def is_generator(f):
     """ Return True if a function is a generator.
     """
-    isgen = (f.func_code.co_flags & CO_GENERATOR) != 0 
+    isgen = (f.__code__.co_flags & CO_GENERATOR) != 0 
     return isgen
 
-# FIXME: refactor this stuff so that both LineProfiler and ContextualProfile can
-# use the same implementation.
-# Code to exec inside of ContextualProfile.__call__ to support PEP-342-style
-# generators in Python 2.5+.
-pep342_gen_wrapper = '''
-def wrap_generator(self, func):
-    """ Wrap a generator to profile it.
-    """
-    def f(*args, **kwds):
-        g = func(*args, **kwds)
-        # The first iterate will not be a .send()
-        self.enable_by_count()
-        try:
-            item = g.next()
-        finally:
-            self.disable_by_count()
-        input = (yield item)
-        # But any following one might be.
-        while True:
-            self.enable_by_count()
-            try:
-                item = g.send(input)
-            finally:
-                self.disable_by_count()
-            input = (yield item)
-    return f
-'''
 
 class ContextualProfile(Profile):
     """ A subclass of Profile that adds a context manager for Python
@@ -95,24 +84,29 @@
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
-    if sys.version_info[:2] >= (2,5):
-        # Delay compilation because the syntax is not compatible with older
-        # Python versions.
-        exec pep342_gen_wrapper
-    else:
-        def wrap_generator(self, func):
-            """ Wrap a generator to profile it.
-            """
-            def f(*args, **kwds):
-                g = func(*args, **kwds)
-                while True:
-                    self.enable_by_count()
-                    try:
-                        item = g.next()
-                    finally:
-                        self.disable_by_count()
-                    yield item
-            return f
+    # FIXME: refactor this stuff so that both LineProfiler and
+    # ContextualProfile can use the same implementation.
+    def wrap_generator(self, func):
+        """ Wrap a generator to profile it.
+        """
+        def f(*args, **kwds):
+            g = func(*args, **kwds)
+            # The first iterate will not be a .send()
+            self.enable_by_count()
+            try:
+                item = next(g)
+            finally:
+                self.disable_by_count()
+            input = (yield item)
+            # But any following one might be.
+            while True:
+                self.enable_by_count()
+                try:
+                    item = g.send(input)
+                finally:
+                    self.disable_by_count()
+                input = (yield item)
+        return f
 
     def wrap_function(self, func):
         """ Wrap a function to profile it.
@@ -148,7 +142,7 @@
         if os.path.isfile(fn):
             return fn
 
-    print >>sys.stderr, 'Could not find script %s' % script_name
+    sys.stderr.write('Could not find script %s\n' % script_name)
     raise SystemExit(1)
 
 def main(args):
@@ -204,8 +198,11 @@
     else:
         prof = ContextualProfile()
     if options.builtin:
-        import __builtin__
-        __builtin__.__dict__['profile'] = prof
+        try:
+            import builtins
+        except ImportError: # Python 2.x
+            import __builtin__ as builtins
+        builtins.__dict__['profile'] = prof
 
     script_file = find_script(sys.argv[0])
     __file__ = script_file
@@ -216,16 +213,17 @@
 
     try:
         try:
+            execfile_ = execfile
             ns = locals()
             if options.builtin:
                 execfile(script_file, ns, ns)
             else:
-                prof.runctx('execfile(%r)' % (script_file,), ns, ns)
+                prof.runctx('execfile_(%r, globals())' % (script_file,), ns, ns)
         except (KeyboardInterrupt, SystemExit):
             pass
     finally:
         prof.dump_stats(options.outfile)
-        print 'Wrote profile results to %s' % options.outfile
+        print('Wrote profile results to %s' % options.outfile)
         if options.view:
             prof.print_stats()
 
diff -u -r line_profiler-1.0b3/line_profiler.py line_profiler/line_profiler.py
--- line_profiler-1.0b3/line_profiler.py	2011-12-06 05:43:58.000000000 -0800
+++ line_profiler/line_profiler.py	2014-01-16 13:38:35.787328127 -0800
@@ -1,8 +1,15 @@
 #!/usr/bin/env python
 # -*- coding: UTF-8 -*-
+try:
+    import cPickle as pickle
+except ImportError:
+    import pickle
+
+try:
+    from cStringIO import StringIO
+except ImportError:
+    from io import StringIO
 
-import cPickle
-from cStringIO import StringIO
 import inspect
 import linecache
 import optparse
@@ -11,40 +18,37 @@
 
 from _line_profiler import LineProfiler as CLineProfiler
 
+# Python 2/3 compatibility utils
+# ===========================================================
+PY3 = sys.version_info[0] == 3
+
+# exec (from https://bitbucket.org/gutworth/six/):
+if PY3:
+    import builtins
+    exec_ = getattr(builtins, "exec")
+    del builtins
+else:
+    def exec_(_code_, _globs_=None, _locs_=None):
+        """Execute code in a namespace."""
+        if _globs_ is None:
+            frame = sys._getframe(1)
+            _globs_ = frame.f_globals
+            if _locs_ is None:
+                _locs_ = frame.f_locals
+            del frame
+        elif _locs_ is None:
+            _locs_ = _globs_
+        exec("""exec _code_ in _globs_, _locs_""")
+
+# ============================================================
 
 CO_GENERATOR = 0x0020
 def is_generator(f):
     """ Return True if a function is a generator.
     """
-    isgen = (f.func_code.co_flags & CO_GENERATOR) != 0 
+    isgen = (f.__code__.co_flags & CO_GENERATOR) != 0 
     return isgen
 
-# Code to exec inside of LineProfiler.__call__ to support PEP-342-style
-# generators in Python 2.5+.
-pep342_gen_wrapper = '''
-def wrap_generator(self, func):
-    """ Wrap a generator to profile it.
-    """
-    def f(*args, **kwds):
-        g = func(*args, **kwds)
-        # The first iterate will not be a .send()
-        self.enable_by_count()
-        try:
-            item = g.next()
-        finally:
-            self.disable_by_count()
-        input = (yield item)
-        # But any following one might be.
-        while True:
-            self.enable_by_count()
-            try:
-                item = g.send(input)
-            finally:
-                self.disable_by_count()
-            input = (yield item)
-    return f
-'''
-
 class LineProfiler(CLineProfiler):
     """ A profiler that records the execution times of individual lines.
     """
@@ -64,24 +68,27 @@
         f.__dict__.update(getattr(func, '__dict__', {}))
         return f
 
-    if sys.version_info[:2] >= (2,5):
-        # Delay compilation because the syntax is not compatible with older
-        # Python versions.
-        exec pep342_gen_wrapper
-    else:
-        def wrap_generator(self, func):
-            """ Wrap a generator to profile it.
-            """
-            def f(*args, **kwds):
-                g = func(*args, **kwds)
-                while True:
-                    self.enable_by_count()
-                    try:
-                        item = g.next()
-                    finally:
-                        self.disable_by_count()
-                    yield item
-            return f
+    def wrap_generator(self, func):
+        """ Wrap a generator to profile it.
+        """
+        def f(*args, **kwds):
+            g = func(*args, **kwds)
+            # The first iterate will not be a .send()
+            self.enable_by_count()
+            try:
+                item = next(g)
+            finally:
+                self.disable_by_count()
+            input = (yield item)
+            # But any following one might be.
+            while True:
+                self.enable_by_count()
+                try:
+                    item = g.send(input)
+                finally:
+                    self.disable_by_count()
+                input = (yield item)
+        return f
 
     def wrap_function(self, func):
         """ Wrap a function to profile it.
@@ -100,11 +107,8 @@
         object from `get_stats()`.
         """
         lstats = self.get_stats()
-        f = open(filename, 'wb')
-        try:
-            cPickle.dump(lstats, f, cPickle.HIGHEST_PROTOCOL)
-        finally:
-            f.close()
+        with open(filename, 'wb') as f:
+            pickle.dump(lstats, f, pickle.HIGHEST_PROTOCOL)
 
     def print_stats(self, stream=None):
         """ Show the gathered statistics.
@@ -116,15 +120,15 @@
         """ Profile a single executable statment in the main namespace.
         """
         import __main__
-        dict = __main__.__dict__
-        return self.runctx(cmd, dict, dict)
+        main_dict = __main__.__dict__
+        return self.runctx(cmd, main_dict, main_dict)
 
     def runctx(self, cmd, globals, locals):
         """ Profile a single executable statement in the given namespaces.
         """
         self.enable_by_count()
         try:
-            exec cmd in globals, locals
+            exec_(cmd, globals, locals)
         finally:
             self.disable_by_count()
         return self
@@ -144,8 +148,8 @@
     """
     if stream is None:
         stream = sys.stdout
-    print >>stream, "File: %s" % filename
-    print >>stream, "Function: %s at line %s" % (func_name, start_lineno)
+    stream.write("File: %s\n" % filename)
+    stream.write("Function: %s at line %s\n" % (func_name, start_lineno))
     template = '%6s %9s %12s %8s %8s  %-s'
     d = {}
     total_time = 0.0
@@ -153,13 +157,13 @@
     for lineno, nhits, time in timings:
         total_time += time
         linenos.append(lineno)
-    print >>stream, "Total time: %g s" % (total_time * unit)
+    stream.write("Total time: %g s\n" % (total_time * unit))
     if not os.path.exists(filename):
-        print >>stream, ""
-        print >>stream, "Could not find file %s" % filename
-        print >>stream, "Are you sure you are running this program from the same directory"
-        print >>stream, "that you ran the profiler from?"
-        print >>stream, "Continuing without the function's contents."
+        stream.write("\n")
+        stream.write("Could not find file %s\n" % filename)
+        stream.write("Are you sure you are running this program from the same directory\n")
+        stream.write("that you ran the profiler from?\n")
+        stream.write("Continuing without the function's contents.\n")
         # Fake empty lines so we can see the timings, if not the code.
         nlines = max(linenos) - min(min(linenos), start_lineno) + 1
         sublines = [''] * nlines
@@ -171,24 +175,28 @@
             '%5.1f' % (100*time / total_time))
     linenos = range(start_lineno, start_lineno + len(sublines))
     empty = ('', '', '', '')
-    header = template % ('Line #', 'Hits', 'Time', 'Per Hit', '% Time', 
+    header = template % ('Line #', 'Hits', 'Time', 'Per Hit', '% Time',
         'Line Contents')
-    print >>stream, ""
-    print >>stream, header
-    print >>stream, '=' * len(header)
+    stream.write("\n")
+    stream.write(header)
+    stream.write("\n")
+    stream.write('=' * len(header))
+    stream.write("\n")
     for lineno, line in zip(linenos, sublines):
         nhits, time, per_hit, percent = d.get(lineno, empty)
-        print >>stream, template % (lineno, nhits, time, per_hit, percent,
-            line.rstrip('\n').rstrip('\r'))
-    print >>stream, ""
+        txt = template % (lineno, nhits, time, per_hit, percent,
+                          line.rstrip('\n').rstrip('\r'))
+        stream.write(txt)
+        stream.write("\n")
+    stream.write("\n")
 
 def show_text(stats, unit, stream=None):
     """ Show text for the given timings.
     """
     if stream is None:
         stream = sys.stdout
-    print >>stream, 'Timer unit: %g s' % unit
-    print >>stream, ''
+
+    stream.write('Timer unit: %g s\n\n' % unit)
     for (fn, lineno, name), timings in sorted(stats.items()):
         show_func(fn, lineno, name, stats[fn, lineno, name], unit, stream=stream)
 
@@ -206,7 +214,7 @@
     pager once the statement has completed.
 
     Options:
-    
+
     -f <function>: LineProfiler only profiles functions and methods it is told
     to profile.  This option tells the profiler about these functions. Multiple
     -f options may be used. The argument may be any expression that gives
@@ -241,7 +249,7 @@
 
     # Escape quote markers.
     opts_def = Struct(D=[''], T=[''], f=[])
-    parameter_s = parameter_s.replace('"',r'\"').replace("'",r"\'")
+    parameter_s = parameter_s.replace('"', r'\"').replace("'", r"\'")
     opts, arg_str = self.parse_options(parameter_s, 'rf:D:T:', list_all=True)
     opts.merge(opts_def)
 
@@ -253,21 +261,25 @@
     for name in opts.f:
         try:
             funcs.append(eval(name, global_ns, local_ns))
-        except Exception, e:
-            raise UsageError('Could not find function %r.\n%s: %s' % (name, 
+        except Exception as e:
+            raise UsageError('Could not find function %r.\n%s: %s' % (name,
                 e.__class__.__name__, e))
 
     profile = LineProfiler(*funcs)
 
     # Add the profiler to the builtins for @profile.
-    import __builtin__
-    if 'profile' in __builtin__.__dict__:
+    if PY3:
+        import builtins
+    else:
+        import __builtin__ as builtins
+
+    if 'profile' in builtins.__dict__:
         had_profile = True
-        old_profile = __builtin__.__dict__['profile']
+        old_profile = builtins.__dict__['profile']
     else:
         had_profile = False
         old_profile = None
-    __builtin__.__dict__['profile'] = profile
+    builtins.__dict__['profile'] = profile
 
     try:
         try:
@@ -280,7 +292,7 @@
                 "profiled.")
     finally:
         if had_profile:
-            __builtin__.__dict__['profile'] = old_profile
+            builtins.__dict__['profile'] = old_profile
 
     # Trap text output.
     stdout_trap = StringIO()
@@ -292,24 +304,24 @@
         page(output, screen_lines=self.shell.rc.screen_length)
     else:
         page(output)
-    print message,
+    print(message, end='')
 
     dump_file = opts.D[0]
     if dump_file:
         profile.dump_stats(dump_file)
-        print '\n*** Profile stats pickled to file',\
-              `dump_file`+'.',message
+        print('\n*** Profile stats pickled to file %r. %s' % (
+            dump_file, message))
 
     text_file = opts.T[0]
     if text_file:
         pfile = open(text_file, 'w')
         pfile.write(output)
         pfile.close()
-        print '\n*** Profile printout saved to text file',\
-              `text_file`+'.',message
+        print('\n*** Profile printout saved to text file %r. %s' % (
+            text_file, message))
 
     return_value = None
-    if opts.has_key('r'):
+    if 'r' in opts:
         return_value = profile
 
     return return_value
@@ -325,13 +337,8 @@
     """ Utility function to load a pickled LineStats object from a given
     filename.
     """
-    f = open(filename, 'rb')
-    try:
-        lstats = cPickle.load(f)
-    finally:
-        f.close()
-    return lstats
-
+    with open(filename, 'rb') as f:
+        return pickle.load(f)
 
 def main():
     usage = "usage: %prog profile.lprof"
diff -u -r line_profiler-1.0b3/_line_profiler.pyx line_profiler/_line_profiler.pyx
--- line_profiler-1.0b3/_line_profiler.pyx	2011-09-19 20:36:54.000000000 -0700
+++ line_profiler/_line_profiler.pyx	2014-01-16 13:04:47.419347471 -0800
@@ -125,7 +125,7 @@
         """ Record line profiling information for the given Python function.
         """
         try:
-            code = func.func_code
+            code = func.__code__
         except AttributeError:
             import warnings
             warnings.warn("Could not extract a code object for the object %r" % (func,))
diff -u -r line_profiler-1.0b3/PKG-INFO line_profiler/PKG-INFO
--- line_profiler-1.0b3/PKG-INFO	2011-12-06 06:36:30.000000000 -0800
+++ line_profiler/PKG-INFO	2014-01-16 14:21:53.331303355 -0800
@@ -1,6 +1,6 @@
 Metadata-Version: 1.0
 Name: line_profiler
-Version: 1.0b3
+Version: 1.0b3+
 Summary: Line-by-line profiler.
 Home-page: http://packages.python.org/line_profiler
 Author: Robert Kern
diff -u -r line_profiler-1.0b3/setup.py line_profiler/setup.py
--- line_profiler-1.0b3/setup.py	2011-12-06 05:51:06.000000000 -0800
+++ line_profiler/setup.py	2014-01-16 14:21:56.887303321 -0800
@@ -7,7 +7,7 @@
     from Cython.Distutils import build_ext
     cmdclass = dict(build_ext=build_ext)
     line_profiler_source = '_line_profiler.pyx'
-except ImportError, e:
+except ImportError:
     warn("Could not import Cython. Using pre-generated C file if available.")
     cmdclass = {}
     line_profiler_source = '_line_profiler.c'
@@ -24,13 +24,13 @@
 
 setup(
     name = 'line_profiler',
-    version = '1.0b3',
+    version = '1.0b3+',
     author = 'Robert Kern',
     author_email = 'robert.kern@enthought.com',
     description = 'Line-by-line profiler.',
     long_description = long_description,
     url = 'http://packages.python.org/line_profiler',
-    ext_modules = [ 
+    ext_modules = [
         Extension('_line_profiler',
                   sources=[line_profiler_source, 'timers.c', 'unset_trace.c'],
                   depends=['python25.pxd'],
@@ -44,6 +44,13 @@
         "Operating System :: OS Independent",
         "Programming Language :: C",
         "Programming Language :: Python",
+        'Programming Language :: Python :: 2',
+        'Programming Language :: Python :: 2.6',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3',
+        'Programming Language :: Python :: 3.2',
+        'Programming Language :: Python :: 3.3',
+        'Programming Language :: Python :: Implementation :: CPython',
         "Topic :: Software Development",
     ],
     py_modules = ['line_profiler'],
