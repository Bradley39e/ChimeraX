--- _mmcif.cpp.orig	2016-01-07 16:15:37.458556028 -0800
+++ _mmcif.cpp	2016-01-07 16:29:44.351886900 -0800
@@ -61,6 +61,26 @@
 	}
 }
 
+static bool
+sequence_to_vector_string(PyObject *seq, std::vector<std::string> *vec)
+{
+	if (!PySequence_Check(seq))
+		return false;
+	int count = PySequence_Length(seq);
+	vec->reserve(count);
+	for (int i = 0; i < count; ++i) {
+		PyObject *o = PySequence_GetItem(seq, i);
+		if (!PyUnicode_Check(o)) {
+			Py_XDECREF(o);
+			return false;
+		}
+		std::string inst = wrappy::PythonUnicode_AsCppString(o);
+		vec->push_back(inst);
+		Py_DECREF(o);
+	}
+	return true;
+}
+
 static PyObject*
 _mmcif_extract_mmCIF_tables(PyObject*, PyObject* _args)
 {
@@ -72,9 +92,9 @@
 		if (!PyUnicode_Check(_ptArg1))
 			throw std::invalid_argument("argument 1 should be a str");
 		std::string cppArg1 = wrappy::PythonUnicode_AsCppString(_ptArg1);
-		if (!?TODO?)
-			throw std::invalid_argument("argument 2 should be a list of str");
-		const std::vector<std::string>& cppArg2 = ?TODO?;
+		std::vector<std::string> cppArg2;
+		if (!sequence_to_vector_string(_ptArg2, &cppArg2))
+			throw std::invalid_argument("argument 2 should be a sequence of str");
 		PyObject* _result = extract_mmCIF_tables(cppArg1.c_str(), cppArg2);
 		return _result;
 	} catch (...) {
@@ -142,9 +162,9 @@
 			return NULL;
 		try {
 			const unsigned char* cppArg1 = reinterpret_cast<unsigned char*>(_ptArg1.buf);
-			if (!?TODO?)
-				throw std::invalid_argument("argument 2 should be a list of str");
-			const std::vector<std::string>& cppArg2 = ?TODO?;
+			std::vector<std::string> cppArg2;
+			if (!sequence_to_vector_string(_ptArg2, &cppArg2))
+				throw std::invalid_argument("argument 2 should be a sequence of str");
 			PyObject* cppArg3 = _ptArg3;
 			PyObject* _result = parse_mmCIF_buffer(cppArg1, cppArg2, cppArg3);
 			PyBuffer_Release(&_ptArg1);
@@ -204,9 +224,9 @@
 			if (!PyUnicode_Check(_ptArg1))
 				throw std::invalid_argument("argument 1 should be a str");
 			std::string cppArg1 = wrappy::PythonUnicode_AsCppString(_ptArg1);
-			if (!?TODO?)
-				throw std::invalid_argument("argument 2 should be a list of str");
-			const std::vector<std::string>& cppArg2 = ?TODO?;
+			std::vector<std::string> cppArg2;
+			if (!sequence_to_vector_string(_ptArg2, &cppArg2))
+				throw std::invalid_argument("argument 2 should be a sequence of str");
 			PyObject* cppArg3 = _ptArg3;
 			PyObject* _result = parse_mmCIF_file(cppArg1.c_str(), cppArg2, cppArg3);
 			return _result;
