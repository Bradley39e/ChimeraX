#version 330 core

#ifdef USE_TEXTURE_MASK

in vec2 tex_coord;
uniform sampler2D tex2d;
uniform vec4 color;
out vec4 frag_color;
void main (void)
{
  float f = ceil(texture(tex2d, tex_coord).r);
  frag_color = color * f;
}

#elif defined(USE_DEPTH_OUTLINE)

in vec2 tex_coord;
uniform sampler2D tex2d;
uniform vec4 color;
uniform vec3 depth_shift_and_jump;
out vec4 frag_color;

void main (void)
{
  float d0 = texture(tex2d, tex_coord).r;
  float ds = texture(tex2d, vec2(tex_coord.s+depth_shift_and_jump.s, tex_coord.t+depth_shift_and_jump.t)).r;
  if (ds < d0 + depth_shift_and_jump.p)
     discard;
  frag_color = color;
}

#else

#ifdef USE_LIGHTING
uniform vec3 key_light_direction;
uniform vec3 key_light_diffuse_color;
uniform vec3 key_light_specular_color;
uniform float key_light_specular_exponent;

uniform vec3 fill_light_direction;
uniform vec3 fill_light_diffuse_color;

uniform vec3 ambient_color;

in vec3 N;
in vec3 v;

#ifdef USE_DEPTH_CUE
uniform float depth_cue_distance;
uniform float depth_cue_darkest;
#endif

#endif

#ifdef USE_VERTEX_COLORS
in vec4 color;
#else
uniform vec4 color;
#endif

#ifdef USE_TEXTURE_2D
in vec2 tex_coord;
uniform sampler2D tex2d;
#endif

#ifdef USE_TEXTURE_3D_AMBIENT
in vec3 ambient_tex_coord;
uniform sampler3D tex3d;
#endif

#ifdef USE_SHADOWS
in vec3 shadow_tex_coord;
uniform sampler2DShadow shadow_map;
#endif

#ifdef USE_RADIAL_WARP
uniform vec2 warp_center;
uniform vec4 radial_warp;
uniform vec4 chromatic_warp;
#endif

out vec4 frag_color;

void main (void)
{
#ifdef USE_TEXTURE_2D
#ifdef USE_RADIAL_WARP
  // Correction of spherical and chromatic aberration for Oculus Rift goggles
  float aspect = 1.25;
  float ds = tex_coord.s - warp_center.s;
  float dt = tex_coord.t - warp_center.t;
  float dx = 2*ds;		// Range -1,1
  float dy = 2*dt*aspect;	// Range -aspect,aspect
  float r2 = dx*dx + dy*dy;
  float f = radial_warp[0] + r2*(radial_warp[1] + r2*(radial_warp[2] + r2*radial_warp[3]));
  // Warp red, green and blue channels different to correct chromatic aberration.
  float fred = f*(chromatic_warp[0] + r2*chromatic_warp[1]);
  float fblue = f*(chromatic_warp[2] + r2*chromatic_warp[3]);
  vec4 cr = texture(tex2d, vec2(warp_center.s+fred*ds,warp_center.t+fred*dt));
  vec4 cg = texture(tex2d, vec2(warp_center.s+f*ds,warp_center.t+f*dt));
  vec4 cb = texture(tex2d, vec2(warp_center.s+fblue*ds,warp_center.t+fblue*dt));
  vec4 fcolor = vec4(cr.r, cg.g, cb.b, cg.a) * color;
#else
  vec4 fcolor = texture(tex2d, tex_coord) * color;
#endif
#else
  vec4 fcolor = color;
#endif

#ifdef USE_LIGHTING
  // Unit normal, with two-sided lighting.
  vec3 N1 = normalize(N) * (gl_FrontFacing ? 1.0 : -1.0);

#ifdef USE_SHADOWS
  float shadow = texture(shadow_map, shadow_tex_coord);
#else
  float shadow = 1;
#endif

  // diffuse color, radiated equally in all directions,
  //   strength based on incoming light direction and surface normal.
  vec3 Idiff = fcolor.rgb * (key_light_diffuse_color * max(-dot(N1,key_light_direction),0.0) * shadow
                             + fill_light_diffuse_color * max(-dot(N1,fill_light_direction),0.0));

  // specular color, reflection of incoming light towards the camera.
  vec3 v1 = normalize(v);			        // Unit vector from camera to surface point
  vec3 R = normalize(reflect(key_light_direction,N1)); 
  vec3 Ispec = key_light_specular_color * pow(max(-dot(R,v1),0.0), key_light_specular_exponent) * shadow;

  // ambient color, uniform intensity light from all surfaces.
  vec3 Iamb = fcolor.rgb * ambient_color;

  // total color
  vec3 Ifrag = Iamb + Idiff + Ispec;

#ifdef USE_DEPTH_CUE
  float dim = max(depth_cue_darkest, 1.0 / max(1.0, dot(v1,v)/depth_cue_distance));
  Ifrag *= dim;
#endif

#ifdef USE_TEXTURE_3D_AMBIENT
  Ifrag *= texture(tex3d, ambient_tex_coord).r;
#endif

#else
  vec3 Ifrag = fcolor.rgb;
#endif

  // transparency
  float a = fcolor.a;
#ifdef USE_LIGHTING
  a = 1.0 - pow(max(1.0-a,0.0), 1.0/max(abs(dot(v1,N1)),0.01));
#endif

  // final color
  frag_color = vec4(Ifrag, a);
}

#endif	// USE_IMAGE_BLEND
